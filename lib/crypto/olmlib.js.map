{"version":3,"sources":["../../src/crypto/olmlib.js"],"names":["olmDevice","oneTimeKey","userId","deviceInfo","deviceId","_verifySignature","getFingerprint","console","error","sid","createOutboundSession","getIdentityKey","key","log","_verifyKeyAndStartSession","anotherjson","require","utils","module","exports","OLM_ALGORITHM","MEGOLM_ALGORITHM","encryptMessageForDevice","resultsObject","ourUserId","ourDeviceId","recipientUserId","recipientDevice","payloadFields","deviceKey","getSessionIdForDevice","sessionId","payload","sender","sender_device","keys","deviceEd25519Key","recipient","recipient_keys","extend","encryptMessage","ensureOlmSessionsForDevices","baseApis","devicesByUser","devicesWithoutSession","result","hasOwnProperty","devices","j","length","push","device","oneTimeKeyAlgorithm","claimOneTimeKeys","res","otk_res","one_time_keys","promises","userRes","deviceRes","keyId","indexOf","warn","then","all","verifySignature","obj","signingUserId","signingDeviceId","signingKey","signKeyId","signatures","userSigs","signature","Error","unsigned","json","stringify"],"mappings":"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","file":"olmlib.js","sourcesContent":["/*\r\nCopyright 2016 OpenMarket Ltd\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n*/\r\n\r\n/**\r\n * @module olmlib\r\n *\r\n * Utilities common to olm encryption algorithms\r\n */\r\n\r\nimport Promise from 'bluebird';\r\nconst anotherjson = require('another-json');\r\n\r\nconst utils = require(\"../utils\");\r\n\r\n/**\r\n * matrix algorithm tag for olm\r\n */\r\nmodule.exports.OLM_ALGORITHM = \"m.olm.v1.curve25519-aes-sha2\";\r\n\r\n/**\r\n * matrix algorithm tag for megolm\r\n */\r\nmodule.exports.MEGOLM_ALGORITHM = \"m.megolm.v1.aes-sha2\";\r\n\r\n\r\n/**\r\n * Encrypt an event payload for an Olm device\r\n *\r\n * @param {Object<string, string>} resultsObject  The `ciphertext` property\r\n *   of the m.room.encrypted event to which to add our result\r\n *\r\n * @param {string} ourUserId\r\n * @param {string} ourDeviceId\r\n * @param {module:crypto/OlmDevice} olmDevice olm.js wrapper\r\n * @param {string} recipientUserId\r\n * @param {module:crypto/deviceinfo} recipientDevice\r\n * @param {object} payloadFields fields to include in the encrypted payload\r\n *\r\n * Returns a promise which resolves (to undefined) when the payload\r\n *    has been encrypted into `resultsObject`\r\n */\r\nmodule.exports.encryptMessageForDevice = async function(\r\n    resultsObject,\r\n    ourUserId, ourDeviceId, olmDevice, recipientUserId, recipientDevice,\r\n    payloadFields,\r\n) {\r\n    const deviceKey = recipientDevice.getIdentityKey();\r\n    const sessionId = await olmDevice.getSessionIdForDevice(deviceKey);\r\n    if (sessionId === null) {\r\n        // If we don't have a session for a device then\r\n        // we can't encrypt a message for it.\r\n        return;\r\n    }\r\n\r\n    console.log(\r\n        \"Using sessionid \" + sessionId + \" for device \" +\r\n            recipientUserId + \":\" + recipientDevice.deviceId,\r\n    );\r\n\r\n    const payload = {\r\n        sender: ourUserId,\r\n        sender_device: ourDeviceId,\r\n\r\n        // Include the Ed25519 key so that the recipient knows what\r\n        // device this message came from.\r\n        // We don't need to include the curve25519 key since the\r\n        // recipient will already know this from the olm headers.\r\n        // When combined with the device keys retrieved from the\r\n        // homeserver signed by the ed25519 key this proves that\r\n        // the curve25519 key and the ed25519 key are owned by\r\n        // the same device.\r\n        keys: {\r\n            \"ed25519\": olmDevice.deviceEd25519Key,\r\n        },\r\n\r\n        // include the recipient device details in the payload,\r\n        // to avoid unknown key attacks, per\r\n        // https://github.com/vector-im/vector-web/issues/2483\r\n        recipient: recipientUserId,\r\n        recipient_keys: {\r\n            \"ed25519\": recipientDevice.getFingerprint(),\r\n        },\r\n    };\r\n\r\n    // TODO: technically, a bunch of that stuff only needs to be included for\r\n    // pre-key messages: after that, both sides know exactly which devices are\r\n    // involved in the session. If we're looking to reduce data transfer in the\r\n    // future, we could elide them for subsequent messages.\r\n\r\n    utils.extend(payload, payloadFields);\r\n\r\n    resultsObject[deviceKey] = await olmDevice.encryptMessage(\r\n        deviceKey, sessionId, JSON.stringify(payload),\r\n    );\r\n};\r\n\r\n/**\r\n * Try to make sure we have established olm sessions for the given devices.\r\n *\r\n * @param {module:crypto/OlmDevice} olmDevice\r\n *\r\n * @param {module:base-apis~MatrixBaseApis} baseApis\r\n *\r\n * @param {object<string, module:crypto/deviceinfo[]>} devicesByUser\r\n *    map from userid to list of devices\r\n *\r\n * @return {module:client.Promise} resolves once the sessions are complete, to\r\n *    an Object mapping from userId to deviceId to\r\n *    {@link module:crypto~OlmSessionResult}\r\n */\r\nmodule.exports.ensureOlmSessionsForDevices = async function(\r\n    olmDevice, baseApis, devicesByUser,\r\n) {\r\n    const devicesWithoutSession = [\r\n        // [userId, deviceId], ...\r\n    ];\r\n    const result = {};\r\n\r\n    for (const userId in devicesByUser) {\r\n        if (!devicesByUser.hasOwnProperty(userId)) {\r\n            continue;\r\n        }\r\n        result[userId] = {};\r\n        const devices = devicesByUser[userId];\r\n        for (let j = 0; j < devices.length; j++) {\r\n            const deviceInfo = devices[j];\r\n            const deviceId = deviceInfo.deviceId;\r\n            const key = deviceInfo.getIdentityKey();\r\n            const sessionId = await olmDevice.getSessionIdForDevice(key);\r\n            if (sessionId === null) {\r\n                devicesWithoutSession.push([userId, deviceId]);\r\n            }\r\n            result[userId][deviceId] = {\r\n                device: deviceInfo,\r\n                sessionId: sessionId,\r\n            };\r\n        }\r\n    }\r\n\r\n    if (devicesWithoutSession.length === 0) {\r\n        return result;\r\n    }\r\n\r\n    // TODO: this has a race condition - if we try to send another message\r\n    // while we are claiming a key, we will end up claiming two and setting up\r\n    // two sessions.\r\n    //\r\n    // That should eventually resolve itself, but it's poor form.\r\n\r\n    const oneTimeKeyAlgorithm = \"signed_curve25519\";\r\n    const res = await baseApis.claimOneTimeKeys(\r\n        devicesWithoutSession, oneTimeKeyAlgorithm,\r\n    );\r\n\r\n    const otk_res = res.one_time_keys || {};\r\n    const promises = [];\r\n    for (const userId in devicesByUser) {\r\n        if (!devicesByUser.hasOwnProperty(userId)) {\r\n            continue;\r\n        }\r\n        const userRes = otk_res[userId] || {};\r\n        const devices = devicesByUser[userId];\r\n        for (let j = 0; j < devices.length; j++) {\r\n            const deviceInfo = devices[j];\r\n            const deviceId = deviceInfo.deviceId;\r\n            if (result[userId][deviceId].sessionId) {\r\n                // we already have a result for this device\r\n                continue;\r\n            }\r\n\r\n            const deviceRes = userRes[deviceId] || {};\r\n            let oneTimeKey = null;\r\n            for (const keyId in deviceRes) {\r\n                if (keyId.indexOf(oneTimeKeyAlgorithm + \":\") === 0) {\r\n                    oneTimeKey = deviceRes[keyId];\r\n                }\r\n            }\r\n\r\n            if (!oneTimeKey) {\r\n                console.warn(\r\n                    \"No one-time keys (alg=\" + oneTimeKeyAlgorithm +\r\n                        \") for device \" + userId + \":\" + deviceId,\r\n                );\r\n                continue;\r\n            }\r\n\r\n            promises.push(\r\n                _verifyKeyAndStartSession(\r\n                    olmDevice, oneTimeKey, userId, deviceInfo,\r\n                ).then((sid) => {\r\n                    result[userId][deviceId].sessionId = sid;\r\n                }),\r\n            );\r\n        }\r\n    }\r\n\r\n    await Promise.all(promises);\r\n    return result;\r\n};\r\n\r\nasync function _verifyKeyAndStartSession(olmDevice, oneTimeKey, userId, deviceInfo) {\r\n    const deviceId = deviceInfo.deviceId;\r\n    try {\r\n        await _verifySignature(\r\n            olmDevice, oneTimeKey, userId, deviceId,\r\n            deviceInfo.getFingerprint(),\r\n        );\r\n    } catch (e) {\r\n        console.error(\r\n            \"Unable to verify signature on one-time key for device \" +\r\n                userId + \":\" + deviceId + \":\", e,\r\n        );\r\n        return null;\r\n    }\r\n\r\n    let sid;\r\n    try {\r\n        sid = await olmDevice.createOutboundSession(\r\n            deviceInfo.getIdentityKey(), oneTimeKey.key,\r\n        );\r\n    } catch (e) {\r\n        // possibly a bad key\r\n        console.error(\"Error starting session with device \" +\r\n                      userId + \":\" + deviceId + \": \" + e);\r\n        return null;\r\n    }\r\n\r\n    console.log(\"Started new sessionid \" + sid +\r\n                \" for device \" + userId + \":\" + deviceId);\r\n    return sid;\r\n}\r\n\r\n\r\n/**\r\n * Verify the signature on an object\r\n *\r\n * @param {module:crypto/OlmDevice} olmDevice olm wrapper to use for verify op\r\n *\r\n * @param {Object} obj object to check signature on. Note that this will be\r\n * stripped of its 'signatures' and 'unsigned' properties.\r\n *\r\n * @param {string} signingUserId  ID of the user whose signature should be checked\r\n *\r\n * @param {string} signingDeviceId  ID of the device whose signature should be checked\r\n *\r\n * @param {string} signingKey   base64-ed ed25519 public key\r\n *\r\n * Returns a promise which resolves (to undefined) if the the signature is good,\r\n * or rejects with an Error if it is bad.\r\n */\r\nconst _verifySignature = module.exports.verifySignature = async function(\r\n    olmDevice, obj, signingUserId, signingDeviceId, signingKey,\r\n) {\r\n    const signKeyId = \"ed25519:\" + signingDeviceId;\r\n    const signatures = obj.signatures || {};\r\n    const userSigs = signatures[signingUserId] || {};\r\n    const signature = userSigs[signKeyId];\r\n    if (!signature) {\r\n        throw Error(\"No signature\");\r\n    }\r\n\r\n    // prepare the canonical json: remove unsigned and signatures, and stringify with\r\n    // anotherjson\r\n    delete obj.unsigned;\r\n    delete obj.signatures;\r\n    const json = anotherjson.stringify(obj);\r\n\r\n    olmDevice.verifySignature(\r\n        signingKey, json, signature,\r\n    );\r\n};\r\n"]}