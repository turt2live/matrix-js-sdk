{"version":3,"sources":["../../src/crypto/index.js"],"names":["crypto","_olmDevice","getOneTimeKeys","oneTimeKeys","oneTimeJson","promises","keyId","curve25519","hasOwnProperty","k","key","push","_signObject","all","_baseApis","uploadKeysRequest","one_time_keys","device_id","_deviceId","res","markKeysAsPublished","_uploadOneTimeKeys","anotherjson","require","utils","OlmDevice","olmlib","algorithms","DeviceInfo","DeviceVerification","DeviceList","default","Crypto","baseApis","sessionStore","userId","deviceId","clientStore","cryptoStore","_sessionStore","_userId","_clientStore","_cryptoStore","_deviceList","_lastOneTimeKeyCheck","_oneTimeKeyCheckInProgress","_roomEncryptors","_roomDecryptors","_supportedAlgorithms","keys","DECRYPTION_CLASSES","_deviceKeys","_globalBlacklistUnverifiedDevices","_outgoingRoomKeyRequestManager","_receivedRoomKeyRequests","_receivedRoomKeyRequestCancellations","_processingRoomKeyRequests","inherits","prototype","init","deviceEd25519Key","deviceCurve25519Key","myDevices","getEndToEndDevicesForUser","deviceInfo","verified","VERIFIED","known","storeEndToEndDevicesForUser","registerEventHandlers","eventEmitter","on","event","member","oldMembership","_onRoomMembership","e","console","error","_onToDeviceEvent","start","stop","getOlmVersion","getDeviceEd25519Key","setGlobalBlacklistUnverifiedDevices","value","getGlobalBlacklistUnverifiedDevices","uploadDeviceKeys","deviceKeys","user_id","then","device_keys","updateOneTimeKeyCount","currentCount","isFinite","_oneTimeKeyCount","TypeError","_maybeUploadOneTimeKeys","uploadPeriod","maxKeysPerCycle","now","Date","maxOneTimeKeys","maxNumberOfOneTimeKeys","keyLimit","Math","floor","uploadLoop","keyCount","resolve","keysThisLoop","min","generateOneTimeKeys","one_time_key_counts","signed_curve25519","Error","undefined","catch","stack","finally","done","downloadKeys","userIds","forceDownload","getStoredDevicesForUser","getStoredDevice","setDeviceVerification","blocked","devices","dev","verificationStatus","UNVERIFIED","BLOCKED","knownStatus","fromStorage","getOlmSessionsForUser","result","j","length","device","deviceKey","getIdentityKey","getSessionInfoForDevice","sessions","deviceIdKey","getEventSenderDeviceInfo","senderKey","getSenderKey","algorithm","getWireContent","forwardingChain","getForwardingCurve25519KeyChain","getDeviceByIdentityKey","getSender","claimedKey","getClaimedEd25519Key","warn","getId","getFingerprint","setRoomEncryption","roomId","config","inhibitDeviceQuery","existingConfig","getEndToEndRoom","AlgClass","ENCRYPTION_CLASSES","storeEndToEndRoom","alg","olmDevice","log","room","getRoom","members","getJoinedMembers","forEach","m","startTrackingDeviceList","refreshOutdatedDeviceLists","ensureOlmSessionsForUsers","users","devicesByUser","i","ensureOlmSessionsForDevices","isRoomEncrypted","Boolean","exportRoomKeys","map","getAllEndToEndInboundGroupSessionKeys","s","exportInboundGroupSession","sessionId","sess","MEGOLM_ALGORITHM","importRoomKeys","room_id","_getRoomDecryptor","importRoomKey","encryptEvent","getRoomId","encryptMessage","getType","getContent","encryptedContent","makeEncrypted","decryptEvent","isRedacted","clearEvent","type","content","handleDeviceListChanges","deviceLists","changed","Array","isArray","u","invalidateUserDeviceList","left","stopTrackingDeviceList","requestRoomKey","requestBody","recipients","sendRoomKeyRequest","cancelRoomKeyRequest","onCryptoEvent","onSyncCompleted","syncData","nextSyncToken","oldSyncToken","getEndToEndDeviceSyncToken","_invalidateDeviceListsSince","invalidateAllDeviceLists","storeEndToEndDeviceSyncToken","lastKnownSyncToken","catchingUp","_processReceivedRoomKeyRequests","getKeyChanges","r","_getE2eRooms","getRooms","filter","me","getMember","membership","_onRoomKeyEvent","_onRoomKeyRequestEvent","isBeingDecrypted","once","ev","onRoomKeyEvent","onRoomMembership","action","req","IncomingRoomKeyRequest","IncomingRoomKeyRequestCancellation","requests","cancellations","_processReceivedRoomKeyRequest","cancellation","_processReceivedRoomKeyRequestCancellation","body","session_id","requestId","decryptor","hasKeysForKeyRequest","share","shareKeysWithDevice","isVerified","emit","decryptors","DecryptionError","obj","sigs","sign","stringify","signatures","requesting_device_id","request_id","module","exports"],"mappings":"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","file":"index.js","sourcesContent":["/*\r\nCopyright 2016 OpenMarket Ltd\r\nCopyright 2017 Vector Creations Ltd\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n*/\r\n\"use strict\";\r\n\r\n/**\r\n * @module crypto\r\n */\r\n\r\nconst anotherjson = require('another-json');\r\nimport Promise from 'bluebird';\r\nimport {EventEmitter} from 'events';\r\n\r\nconst utils = require(\"../utils\");\r\nconst OlmDevice = require(\"./OlmDevice\");\r\nconst olmlib = require(\"./olmlib\");\r\nconst algorithms = require(\"./algorithms\");\r\nconst DeviceInfo = require(\"./deviceinfo\");\r\nconst DeviceVerification = DeviceInfo.DeviceVerification;\r\nconst DeviceList = require('./DeviceList').default;\r\n\r\nimport OutgoingRoomKeyRequestManager from './OutgoingRoomKeyRequestManager';\r\n\r\n/**\r\n * Cryptography bits\r\n *\r\n * This module is internal to the js-sdk; the public API is via MatrixClient.\r\n *\r\n * @constructor\r\n * @alias module:crypto\r\n *\r\n * @internal\r\n *\r\n * @param {module:base-apis~MatrixBaseApis} baseApis base matrix api interface\r\n *\r\n * @param {module:store/session/webstorage~WebStorageSessionStore} sessionStore\r\n *    Store to be used for end-to-end crypto session data\r\n *\r\n * @param {string} userId The user ID for the local user\r\n *\r\n * @param {string} deviceId The identifier for this device.\r\n *\r\n * @param {Object} clientStore the MatrixClient data store.\r\n *\r\n * @param {module:crypto/store/base~CryptoStore} cryptoStore\r\n *    storage for the crypto layer.\r\n */\r\nfunction Crypto(baseApis, sessionStore, userId, deviceId,\r\n                clientStore, cryptoStore) {\r\n    this._baseApis = baseApis;\r\n    this._sessionStore = sessionStore;\r\n    this._userId = userId;\r\n    this._deviceId = deviceId;\r\n    this._clientStore = clientStore;\r\n    this._cryptoStore = cryptoStore;\r\n\r\n    this._olmDevice = new OlmDevice(sessionStore);\r\n    this._deviceList = new DeviceList(baseApis, sessionStore, this._olmDevice);\r\n\r\n    // the last time we did a check for the number of one-time-keys on the\r\n    // server.\r\n    this._lastOneTimeKeyCheck = null;\r\n    this._oneTimeKeyCheckInProgress = false;\r\n\r\n    // EncryptionAlgorithm instance for each room\r\n    this._roomEncryptors = {};\r\n\r\n    // map from algorithm to DecryptionAlgorithm instance, for each room\r\n    this._roomDecryptors = {};\r\n\r\n    this._supportedAlgorithms = utils.keys(\r\n        algorithms.DECRYPTION_CLASSES,\r\n    );\r\n\r\n    this._deviceKeys = {};\r\n\r\n    this._globalBlacklistUnverifiedDevices = false;\r\n\r\n    this._outgoingRoomKeyRequestManager = new OutgoingRoomKeyRequestManager(\r\n         baseApis, this._deviceId, this._cryptoStore,\r\n    );\r\n\r\n    // list of IncomingRoomKeyRequests/IncomingRoomKeyRequestCancellations\r\n    // we received in the current sync.\r\n    this._receivedRoomKeyRequests = [];\r\n    this._receivedRoomKeyRequestCancellations = [];\r\n    // true if we are currently processing received room key requests\r\n    this._processingRoomKeyRequests = false;\r\n}\r\nutils.inherits(Crypto, EventEmitter);\r\n\r\n/**\r\n * Initialise the crypto module so that it is ready for use\r\n *\r\n * Returns a promise which resolves once the crypto module is ready for use.\r\n */\r\nCrypto.prototype.init = async function() {\r\n    await this._olmDevice.init();\r\n\r\n    // build our device keys: these will later be uploaded\r\n    this._deviceKeys[\"ed25519:\" + this._deviceId] =\r\n        this._olmDevice.deviceEd25519Key;\r\n    this._deviceKeys[\"curve25519:\" + this._deviceId] =\r\n        this._olmDevice.deviceCurve25519Key;\r\n\r\n    let myDevices = this._sessionStore.getEndToEndDevicesForUser(\r\n        this._userId,\r\n    );\r\n\r\n    if (!myDevices) {\r\n        myDevices = {};\r\n    }\r\n\r\n    if (!myDevices[this._deviceId]) {\r\n        // add our own deviceinfo to the sessionstore\r\n        const deviceInfo = {\r\n            keys: this._deviceKeys,\r\n            algorithms: this._supportedAlgorithms,\r\n            verified: DeviceVerification.VERIFIED,\r\n            known: true,\r\n        };\r\n\r\n        myDevices[this._deviceId] = deviceInfo;\r\n        this._sessionStore.storeEndToEndDevicesForUser(\r\n            this._userId, myDevices,\r\n        );\r\n    }\r\n};\r\n\r\n/**\r\n * Tell the crypto module to register for MatrixClient events which it needs to\r\n * listen for\r\n *\r\n * @param {external:EventEmitter} eventEmitter event source where we can register\r\n *    for event notifications\r\n */\r\nCrypto.prototype.registerEventHandlers = function(eventEmitter) {\r\n    const crypto = this;\r\n\r\n    eventEmitter.on(\"RoomMember.membership\", function(event, member, oldMembership) {\r\n        try {\r\n            crypto._onRoomMembership(event, member, oldMembership);\r\n        } catch (e) {\r\n             console.error(\"Error handling membership change:\", e);\r\n        }\r\n    });\r\n\r\n    eventEmitter.on(\"toDeviceEvent\", function(event) {\r\n        crypto._onToDeviceEvent(event);\r\n    });\r\n};\r\n\r\n\r\n/** Start background processes related to crypto */\r\nCrypto.prototype.start = function() {\r\n    this._outgoingRoomKeyRequestManager.start();\r\n};\r\n\r\n/** Stop background processes related to crypto */\r\nCrypto.prototype.stop = function() {\r\n    this._outgoingRoomKeyRequestManager.stop();\r\n};\r\n\r\n/**\r\n * @return {string} The version of Olm.\r\n */\r\nCrypto.getOlmVersion = function() {\r\n    return OlmDevice.getOlmVersion();\r\n};\r\n\r\n/**\r\n * Get the Ed25519 key for this device\r\n *\r\n * @return {string} base64-encoded ed25519 key.\r\n */\r\nCrypto.prototype.getDeviceEd25519Key = function() {\r\n    return this._olmDevice.deviceEd25519Key;\r\n};\r\n\r\n/**\r\n * Set the global override for whether the client should ever send encrypted\r\n * messages to unverified devices.  If false, it can still be overridden\r\n * per-room.  If true, it overrides the per-room settings.\r\n *\r\n * @param {boolean} value whether to unilaterally blacklist all\r\n * unverified devices\r\n */\r\nCrypto.prototype.setGlobalBlacklistUnverifiedDevices = function(value) {\r\n    this._globalBlacklistUnverifiedDevices = value;\r\n};\r\n\r\n/**\r\n * @return {boolean} whether to unilaterally blacklist all unverified devices\r\n */\r\nCrypto.prototype.getGlobalBlacklistUnverifiedDevices = function() {\r\n    return this._globalBlacklistUnverifiedDevices;\r\n};\r\n\r\n/**\r\n * Upload the device keys to the homeserver.\r\n * @return {object} A promise that will resolve when the keys are uploaded.\r\n */\r\nCrypto.prototype.uploadDeviceKeys = function() {\r\n    const crypto = this;\r\n    const userId = crypto._userId;\r\n    const deviceId = crypto._deviceId;\r\n\r\n    const deviceKeys = {\r\n        algorithms: crypto._supportedAlgorithms,\r\n        device_id: deviceId,\r\n        keys: crypto._deviceKeys,\r\n        user_id: userId,\r\n    };\r\n\r\n    return crypto._signObject(deviceKeys).then(() => {\r\n        crypto._baseApis.uploadKeysRequest({\r\n            device_keys: deviceKeys,\r\n        }, {\r\n            // for now, we set the device id explicitly, as we may not be using the\r\n            // same one as used in login.\r\n            device_id: deviceId,\r\n        });\r\n    });\r\n};\r\n\r\n/**\r\n * Stores the current one_time_key count which will be handled later (in a call of\r\n * onSyncCompleted). The count is e.g. coming from a /sync response.\r\n *\r\n * @param {Number} currentCount The current count of one_time_keys to be stored\r\n */\r\nCrypto.prototype.updateOneTimeKeyCount = function(currentCount) {\r\n    if (isFinite(currentCount)) {\r\n        this._oneTimeKeyCount = currentCount;\r\n    } else {\r\n        throw new TypeError(\"Parameter for updateOneTimeKeyCount has to be a number\");\r\n    }\r\n};\r\n\r\n// check if it's time to upload one-time keys, and do so if so.\r\nfunction _maybeUploadOneTimeKeys(crypto) {\r\n    // frequency with which to check & upload one-time keys\r\n    const uploadPeriod = 1000 * 60; // one minute\r\n\r\n    // max number of keys to upload at once\r\n    // Creating keys can be an expensive operation so we limit the\r\n    // number we generate in one go to avoid blocking the application\r\n    // for too long.\r\n    const maxKeysPerCycle = 5;\r\n\r\n    if (crypto._oneTimeKeyCheckInProgress) {\r\n        return;\r\n    }\r\n\r\n    const now = Date.now();\r\n    if (crypto._lastOneTimeKeyCheck !== null &&\r\n        now - crypto._lastOneTimeKeyCheck < uploadPeriod\r\n       ) {\r\n        // we've done a key upload recently.\r\n        return;\r\n    }\r\n\r\n    crypto._lastOneTimeKeyCheck = now;\r\n\r\n    // We need to keep a pool of one time public keys on the server so that\r\n    // other devices can start conversations with us. But we can only store\r\n    // a finite number of private keys in the olm Account object.\r\n    // To complicate things further then can be a delay between a device\r\n    // claiming a public one time key from the server and it sending us a\r\n    // message. We need to keep the corresponding private key locally until\r\n    // we receive the message.\r\n    // But that message might never arrive leaving us stuck with duff\r\n    // private keys clogging up our local storage.\r\n    // So we need some kind of enginering compromise to balance all of\r\n    // these factors.\r\n\r\n    // Check how many keys we can store in the Account object.\r\n    const maxOneTimeKeys = crypto._olmDevice.maxNumberOfOneTimeKeys();\r\n    // Try to keep at most half that number on the server. This leaves the\r\n    // rest of the slots free to hold keys that have been claimed from the\r\n    // server but we haven't recevied a message for.\r\n    // If we run out of slots when generating new keys then olm will\r\n    // discard the oldest private keys first. This will eventually clean\r\n    // out stale private keys that won't receive a message.\r\n    const keyLimit = Math.floor(maxOneTimeKeys / 2);\r\n\r\n    function uploadLoop(keyCount) {\r\n        if (keyLimit <= keyCount) {\r\n            // If we don't need to generate any more keys then we are done.\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const keysThisLoop = Math.min(keyLimit - keyCount, maxKeysPerCycle);\r\n\r\n        // Ask olm to generate new one time keys, then upload them to synapse.\r\n        return crypto._olmDevice.generateOneTimeKeys(keysThisLoop).then(() => {\r\n            return _uploadOneTimeKeys(crypto);\r\n        }).then((res) => {\r\n            if (res.one_time_key_counts && res.one_time_key_counts.signed_curve25519) {\r\n                // if the response contains a more up to date value use this\r\n                // for the next loop\r\n                return uploadLoop(res.one_time_key_counts.signed_curve25519);\r\n            } else {\r\n                throw new Error(\"response for uploading keys does not contain \"\r\n                              + \"one_time_key_counts.signed_curve25519\");\r\n            }\r\n        });\r\n    }\r\n\r\n    crypto._oneTimeKeyCheckInProgress = true;\r\n    Promise.resolve().then(() => {\r\n        if (crypto._oneTimeKeyCount !== undefined) {\r\n            // We already have the current one_time_key count from a /sync response.\r\n            // Use this value instead of asking the server for the current key count.\r\n            return Promise.resolve(crypto._oneTimeKeyCount);\r\n        }\r\n        // ask the server how many keys we have\r\n        return crypto._baseApis.uploadKeysRequest({}, {\r\n            device_id: crypto._deviceId,\r\n        }).then((res) => {\r\n            return res.one_time_key_counts.signed_curve25519 || 0;\r\n        });\r\n    }).then((keyCount) => {\r\n        // Start the uploadLoop with the current keyCount. The function checks if\r\n        // we need to upload new keys or not.\r\n        // If there are too many keys on the server then we don't need to\r\n        // create any more keys.\r\n        return uploadLoop(keyCount);\r\n    }).catch((e) => {\r\n        console.error(\"Error uploading one-time keys\", e.stack || e);\r\n    }).finally(() => {\r\n        // reset _oneTimeKeyCount to prevent start uploading based on old data.\r\n        // it will be set again on the next /sync-response\r\n        crypto._oneTimeKeyCount = undefined;\r\n        crypto._oneTimeKeyCheckInProgress = false;\r\n    }).done();\r\n}\r\n\r\n// returns a promise which resolves to the response\r\nasync function _uploadOneTimeKeys(crypto) {\r\n    const oneTimeKeys = await crypto._olmDevice.getOneTimeKeys();\r\n    const oneTimeJson = {};\r\n\r\n    const promises = [];\r\n\r\n    for (const keyId in oneTimeKeys.curve25519) {\r\n        if (oneTimeKeys.curve25519.hasOwnProperty(keyId)) {\r\n            const k = {\r\n                key: oneTimeKeys.curve25519[keyId],\r\n            };\r\n            oneTimeJson[\"signed_curve25519:\" + keyId] = k;\r\n            promises.push(crypto._signObject(k));\r\n        }\r\n    }\r\n\r\n    await Promise.all(promises);\r\n\r\n    const res = await crypto._baseApis.uploadKeysRequest({\r\n        one_time_keys: oneTimeJson,\r\n    }, {\r\n        // for now, we set the device id explicitly, as we may not be using the\r\n        // same one as used in login.\r\n        device_id: crypto._deviceId,\r\n    });\r\n\r\n    await crypto._olmDevice.markKeysAsPublished();\r\n    return res;\r\n}\r\n\r\n/**\r\n * Download the keys for a list of users and stores the keys in the session\r\n * store.\r\n * @param {Array} userIds The users to fetch.\r\n * @param {bool} forceDownload Always download the keys even if cached.\r\n *\r\n * @return {Promise} A promise which resolves to a map userId->deviceId->{@link\r\n * module:crypto/deviceinfo|DeviceInfo}.\r\n */\r\nCrypto.prototype.downloadKeys = function(userIds, forceDownload) {\r\n    return this._deviceList.downloadKeys(userIds, forceDownload);\r\n};\r\n\r\n/**\r\n * Get the stored device keys for a user id\r\n *\r\n * @param {string} userId the user to list keys for.\r\n *\r\n * @return {module:crypto/deviceinfo[]|null} list of devices, or null if we haven't\r\n * managed to get a list of devices for this user yet.\r\n */\r\nCrypto.prototype.getStoredDevicesForUser = function(userId) {\r\n    return this._deviceList.getStoredDevicesForUser(userId);\r\n};\r\n\r\n/**\r\n * Get the stored keys for a single device\r\n *\r\n * @param {string} userId\r\n * @param {string} deviceId\r\n *\r\n * @return {module:crypto/deviceinfo?} device, or undefined\r\n * if we don't know about this device\r\n */\r\nCrypto.prototype.getStoredDevice = function(userId, deviceId) {\r\n    return this._deviceList.getStoredDevice(userId, deviceId);\r\n};\r\n\r\n/**\r\n * Update the blocked/verified state of the given device\r\n *\r\n * @param {string} userId owner of the device\r\n * @param {string} deviceId unique identifier for the device\r\n *\r\n * @param {?boolean} verified whether to mark the device as verified. Null to\r\n *     leave unchanged.\r\n *\r\n * @param {?boolean} blocked whether to mark the device as blocked. Null to\r\n *      leave unchanged.\r\n *\r\n * @param {?boolean} known whether to mark that the user has been made aware of\r\n *      the existence of this device. Null to leave unchanged\r\n *\r\n * @return {Promise<module:crypto/deviceinfo>} updated DeviceInfo\r\n */\r\nCrypto.prototype.setDeviceVerification = async function(\r\n    userId, deviceId, verified, blocked, known,\r\n) {\r\n    const devices = this._sessionStore.getEndToEndDevicesForUser(userId);\r\n    if (!devices || !devices[deviceId]) {\r\n        throw new Error(\"Unknown device \" + userId + \":\" + deviceId);\r\n    }\r\n\r\n    const dev = devices[deviceId];\r\n    let verificationStatus = dev.verified;\r\n\r\n    if (verified) {\r\n        verificationStatus = DeviceVerification.VERIFIED;\r\n    } else if (verified !== null && verificationStatus == DeviceVerification.VERIFIED) {\r\n        verificationStatus = DeviceVerification.UNVERIFIED;\r\n    }\r\n\r\n    if (blocked) {\r\n        verificationStatus = DeviceVerification.BLOCKED;\r\n    } else if (blocked !== null && verificationStatus == DeviceVerification.BLOCKED) {\r\n        verificationStatus = DeviceVerification.UNVERIFIED;\r\n    }\r\n\r\n    let knownStatus = dev.known;\r\n    if (known !== null && known !== undefined) {\r\n        knownStatus = known;\r\n    }\r\n\r\n    if (dev.verified !== verificationStatus || dev.known !== knownStatus) {\r\n        dev.verified = verificationStatus;\r\n        dev.known = knownStatus;\r\n        this._sessionStore.storeEndToEndDevicesForUser(userId, devices);\r\n    }\r\n    return DeviceInfo.fromStorage(dev, deviceId);\r\n};\r\n\r\n\r\n/**\r\n * Get information on the active olm sessions with a user\r\n * <p>\r\n * Returns a map from device id to an object with keys 'deviceIdKey' (the\r\n * device's curve25519 identity key) and 'sessions' (an array of objects in the\r\n * same format as that returned by\r\n * {@link module:crypto/OlmDevice#getSessionInfoForDevice}).\r\n * <p>\r\n * This method is provided for debugging purposes.\r\n *\r\n * @param {string} userId id of user to inspect\r\n *\r\n * @return {Promise<Object.<string, {deviceIdKey: string, sessions: object[]}>>}\r\n */\r\nCrypto.prototype.getOlmSessionsForUser = async function(userId) {\r\n    const devices = this.getStoredDevicesForUser(userId) || [];\r\n    const result = {};\r\n    for (let j = 0; j < devices.length; ++j) {\r\n        const device = devices[j];\r\n        const deviceKey = device.getIdentityKey();\r\n        const sessions = await this._olmDevice.getSessionInfoForDevice(deviceKey);\r\n\r\n        result[device.deviceId] = {\r\n            deviceIdKey: deviceKey,\r\n            sessions: sessions,\r\n        };\r\n    }\r\n    return result;\r\n};\r\n\r\n\r\n/**\r\n * Get the device which sent an event\r\n *\r\n * @param {module:models/event.MatrixEvent} event event to be checked\r\n *\r\n * @return {module:crypto/deviceinfo?}\r\n */\r\nCrypto.prototype.getEventSenderDeviceInfo = function(event) {\r\n    const senderKey = event.getSenderKey();\r\n    const algorithm = event.getWireContent().algorithm;\r\n\r\n    if (!senderKey || !algorithm) {\r\n        return null;\r\n    }\r\n\r\n    const forwardingChain = event.getForwardingCurve25519KeyChain();\r\n    if (forwardingChain.length > 0) {\r\n        // we got this event from somewhere else\r\n        // TODO: check if we can trust the forwarders.\r\n        return null;\r\n    }\r\n\r\n    // senderKey is the Curve25519 identity key of the device which the event\r\n    // was sent from. In the case of Megolm, it's actually the Curve25519\r\n    // identity key of the device which set up the Megolm session.\r\n\r\n    const device = this._deviceList.getDeviceByIdentityKey(\r\n        event.getSender(), algorithm, senderKey,\r\n    );\r\n\r\n    if (device === null) {\r\n        // we haven't downloaded the details of this device yet.\r\n        return null;\r\n    }\r\n\r\n    // so far so good, but now we need to check that the sender of this event\r\n    // hadn't advertised someone else's Curve25519 key as their own. We do that\r\n    // by checking the Ed25519 claimed by the event (or, in the case of megolm,\r\n    // the event which set up the megolm session), to check that it matches the\r\n    // fingerprint of the purported sending device.\r\n    //\r\n    // (see https://github.com/vector-im/vector-web/issues/2215)\r\n\r\n    const claimedKey = event.getClaimedEd25519Key();\r\n    if (!claimedKey) {\r\n        console.warn(\"Event \" + event.getId() + \" claims no ed25519 key: \" +\r\n                     \"cannot verify sending device\");\r\n        return null;\r\n    }\r\n\r\n    if (claimedKey !== device.getFingerprint()) {\r\n        console.warn(\r\n            \"Event \" + event.getId() + \" claims ed25519 key \" + claimedKey +\r\n                \"but sender device has key \" + device.getFingerprint());\r\n        return null;\r\n    }\r\n\r\n    return device;\r\n};\r\n\r\n\r\n/**\r\n * Configure a room to use encryption (ie, save a flag in the sessionstore).\r\n *\r\n * @param {string} roomId The room ID to enable encryption in.\r\n *\r\n * @param {object} config The encryption config for the room.\r\n *\r\n * @param {boolean=} inhibitDeviceQuery true to suppress device list query for\r\n *   users in the room (for now)\r\n */\r\nCrypto.prototype.setRoomEncryption = async function(roomId, config, inhibitDeviceQuery) {\r\n    // if we already have encryption in this room, we should ignore this event\r\n    // (for now at least. maybe we should alert the user somehow?)\r\n    const existingConfig = this._sessionStore.getEndToEndRoom(roomId);\r\n    if (existingConfig) {\r\n        if (JSON.stringify(existingConfig) != JSON.stringify(config)) {\r\n            console.error(\"Ignoring m.room.encryption event which requests \" +\r\n                          \"a change of config in \" + roomId);\r\n            return;\r\n        }\r\n    }\r\n\r\n    const AlgClass = algorithms.ENCRYPTION_CLASSES[config.algorithm];\r\n    if (!AlgClass) {\r\n        throw new Error(\"Unable to encrypt with \" + config.algorithm);\r\n    }\r\n\r\n    this._sessionStore.storeEndToEndRoom(roomId, config);\r\n\r\n    const alg = new AlgClass({\r\n        userId: this._userId,\r\n        deviceId: this._deviceId,\r\n        crypto: this,\r\n        olmDevice: this._olmDevice,\r\n        baseApis: this._baseApis,\r\n        roomId: roomId,\r\n        config: config,\r\n    });\r\n    this._roomEncryptors[roomId] = alg;\r\n\r\n    // make sure we are tracking the device lists for all users in this room.\r\n    console.log(\"Enabling encryption in \" + roomId + \"; \" +\r\n                \"starting to track device lists for all users therein\");\r\n    const room = this._clientStore.getRoom(roomId);\r\n    if (!room) {\r\n        throw new Error(`Unable to enable encryption in unknown room ${roomId}`);\r\n    }\r\n\r\n    const members = room.getJoinedMembers();\r\n    members.forEach((m) => {\r\n        this._deviceList.startTrackingDeviceList(m.userId);\r\n    });\r\n    if (!inhibitDeviceQuery) {\r\n        this._deviceList.refreshOutdatedDeviceLists();\r\n    }\r\n};\r\n\r\n\r\n/**\r\n * @typedef {Object} module:crypto~OlmSessionResult\r\n * @property {module:crypto/deviceinfo} device  device info\r\n * @property {string?} sessionId base64 olm session id; null if no session\r\n *    could be established\r\n */\r\n\r\n/**\r\n * Try to make sure we have established olm sessions for all known devices for\r\n * the given users.\r\n *\r\n * @param {string[]} users list of user ids\r\n *\r\n * @return {module:client.Promise} resolves once the sessions are complete, to\r\n *    an Object mapping from userId to deviceId to\r\n *    {@link module:crypto~OlmSessionResult}\r\n */\r\nCrypto.prototype.ensureOlmSessionsForUsers = function(users) {\r\n    const devicesByUser = {};\r\n\r\n    for (let i = 0; i < users.length; ++i) {\r\n        const userId = users[i];\r\n        devicesByUser[userId] = [];\r\n\r\n        const devices = this.getStoredDevicesForUser(userId) || [];\r\n        for (let j = 0; j < devices.length; ++j) {\r\n            const deviceInfo = devices[j];\r\n\r\n            const key = deviceInfo.getIdentityKey();\r\n            if (key == this._olmDevice.deviceCurve25519Key) {\r\n                // don't bother setting up session to ourself\r\n                continue;\r\n            }\r\n            if (deviceInfo.verified == DeviceVerification.BLOCKED) {\r\n                // don't bother setting up sessions with blocked users\r\n                continue;\r\n            }\r\n\r\n            devicesByUser[userId].push(deviceInfo);\r\n        }\r\n    }\r\n\r\n    return olmlib.ensureOlmSessionsForDevices(\r\n        this._olmDevice, this._baseApis, devicesByUser,\r\n    );\r\n};\r\n\r\n/**\r\n * Whether encryption is enabled for a room.\r\n * @param {string} roomId the room id to query.\r\n * @return {bool} whether encryption is enabled.\r\n */\r\nCrypto.prototype.isRoomEncrypted = function(roomId) {\r\n    return Boolean(this._roomEncryptors[roomId]);\r\n};\r\n\r\n\r\n/**\r\n * Get a list containing all of the room keys\r\n *\r\n * @return {module:client.Promise} a promise which resolves to a list of\r\n *    session export objects\r\n */\r\nCrypto.prototype.exportRoomKeys = function() {\r\n    return Promise.map(\r\n        this._sessionStore.getAllEndToEndInboundGroupSessionKeys(),\r\n        (s) => {\r\n            return this._olmDevice.exportInboundGroupSession(\r\n                s.senderKey, s.sessionId,\r\n            ).then((sess) => {\r\n                sess.algorithm = olmlib.MEGOLM_ALGORITHM;\r\n                return sess;\r\n            });\r\n        },\r\n    );\r\n};\r\n\r\n/**\r\n * Import a list of room keys previously exported by exportRoomKeys\r\n *\r\n * @param {Object[]} keys a list of session export objects\r\n * @return {module:client.Promise} a promise which resolves once the keys have been imported\r\n */\r\nCrypto.prototype.importRoomKeys = function(keys) {\r\n    return Promise.map(\r\n        keys, (key) => {\r\n            if (!key.room_id || !key.algorithm) {\r\n                console.warn(\"ignoring room key entry with missing fields\", key);\r\n                return null;\r\n            }\r\n\r\n            const alg = this._getRoomDecryptor(key.room_id, key.algorithm);\r\n            return alg.importRoomKey(key);\r\n        },\r\n    );\r\n};\r\n\r\n/**\r\n * Encrypt an event according to the configuration of the room.\r\n *\r\n * @param {module:models/event.MatrixEvent} event  event to be sent\r\n *\r\n * @param {module:models/room} room destination room.\r\n *\r\n * @return {module:client.Promise?} Promise which resolves when the event has been\r\n *     encrypted, or null if nothing was needed\r\n */\r\nCrypto.prototype.encryptEvent = function(event, room) {\r\n    if (!room) {\r\n        throw new Error(\"Cannot send encrypted messages in unknown rooms\");\r\n    }\r\n\r\n    const roomId = event.getRoomId();\r\n\r\n    const alg = this._roomEncryptors[roomId];\r\n    if (!alg) {\r\n        // MatrixClient has already checked that this room should be encrypted,\r\n        // so this is an unexpected situation.\r\n        throw new Error(\r\n            \"Room was previously configured to use encryption, but is \" +\r\n            \"no longer. Perhaps the homeserver is hiding the \" +\r\n            \"configuration event.\",\r\n        );\r\n    }\r\n\r\n    return alg.encryptMessage(\r\n        room, event.getType(), event.getContent(),\r\n    ).then((encryptedContent) => {\r\n        event.makeEncrypted(\r\n            \"m.room.encrypted\",\r\n            encryptedContent,\r\n            this._olmDevice.deviceCurve25519Key,\r\n            this._olmDevice.deviceEd25519Key,\r\n        );\r\n    });\r\n};\r\n\r\n/**\r\n * Decrypt a received event\r\n *\r\n * @param {MatrixEvent} event\r\n *\r\n * @return {Promise<module:crypto~EventDecryptionResult>} resolves once we have\r\n *  finished decrypting. Rejects with an `algorithms.DecryptionError` if there\r\n *  is a problem decrypting the event.\r\n */\r\nCrypto.prototype.decryptEvent = function(event) {\r\n    if (event.isRedacted()) {\r\n        return Promise.resolve({\r\n            clearEvent: {\r\n                room_id: event.getRoomId(),\r\n                type: \"m.room.message\",\r\n                content: {},\r\n            },\r\n        });\r\n    }\r\n    const content = event.getWireContent();\r\n    const alg = this._getRoomDecryptor(event.getRoomId(), content.algorithm);\r\n    return alg.decryptEvent(event);\r\n};\r\n\r\n/**\r\n * Handle the notification from /sync or /keys/changes that device lists have\r\n * been changed.\r\n *\r\n * @param {Object} deviceLists device_lists field from /sync, or response from\r\n * /keys/changes\r\n */\r\nCrypto.prototype.handleDeviceListChanges = async function(deviceLists) {\r\n    if (deviceLists.changed && Array.isArray(deviceLists.changed)) {\r\n        deviceLists.changed.forEach((u) => {\r\n            this._deviceList.invalidateUserDeviceList(u);\r\n        });\r\n    }\r\n\r\n    if (deviceLists.left && Array.isArray(deviceLists.left)) {\r\n        deviceLists.left.forEach((u) => {\r\n            this._deviceList.stopTrackingDeviceList(u);\r\n        });\r\n    }\r\n\r\n    // don't flush the outdated device list yet - we do it once we finish\r\n    // processing the sync.\r\n};\r\n\r\n/**\r\n * Send a request for some room keys, if we have not already done so\r\n *\r\n * @param {module:crypto~RoomKeyRequestBody} requestBody\r\n * @param {Array<{userId: string, deviceId: string}>} recipients\r\n */\r\nCrypto.prototype.requestRoomKey = function(requestBody, recipients) {\r\n    this._outgoingRoomKeyRequestManager.sendRoomKeyRequest(\r\n        requestBody, recipients,\r\n    ).catch((e) => {\r\n        // this normally means we couldn't talk to the store\r\n        console.error(\r\n            'Error requesting key for event', e,\r\n        );\r\n    }).done();\r\n};\r\n\r\n/**\r\n * Cancel any earlier room key request\r\n *\r\n * @param {module:crypto~RoomKeyRequestBody} requestBody\r\n *    parameters to match for cancellation\r\n */\r\nCrypto.prototype.cancelRoomKeyRequest = function(requestBody) {\r\n    this._outgoingRoomKeyRequestManager.cancelRoomKeyRequest(requestBody)\r\n    .catch((e) => {\r\n        console.warn(\"Error clearing pending room key requests\", e);\r\n    }).done();\r\n};\r\n\r\n/**\r\n * handle an m.room.encryption event\r\n *\r\n * @param {module:models/event.MatrixEvent} event encryption event\r\n */\r\nCrypto.prototype.onCryptoEvent = async function(event) {\r\n    const roomId = event.getRoomId();\r\n    const content = event.getContent();\r\n\r\n    try {\r\n        // inhibit the device list refresh for now - it will happen once we've\r\n        // finished processing the sync, in onSyncCompleted.\r\n        await this.setRoomEncryption(roomId, content, true);\r\n    } catch (e) {\r\n        console.error(\"Error configuring encryption in room \" + roomId +\r\n                      \":\", e);\r\n    }\r\n};\r\n\r\n/**\r\n * handle the completion of a /sync\r\n *\r\n * This is called after the processing of each successful /sync response.\r\n * It is an opportunity to do a batch process on the information received.\r\n *\r\n * @param {Object} syncData  the data from the 'MatrixClient.sync' event\r\n */\r\nCrypto.prototype.onSyncCompleted = async function(syncData) {\r\n    const nextSyncToken = syncData.nextSyncToken;\r\n\r\n    if (!syncData.oldSyncToken) {\r\n        console.log(\"Completed initial sync\");\r\n\r\n        // if we have a deviceSyncToken, we can tell the deviceList to\r\n        // invalidate devices which have changed since then.\r\n        const oldSyncToken = this._sessionStore.getEndToEndDeviceSyncToken();\r\n        if (oldSyncToken !== null) {\r\n            try {\r\n                await this._invalidateDeviceListsSince(\r\n                    oldSyncToken, nextSyncToken,\r\n                );\r\n            } catch (e) {\r\n                // if that failed, we fall back to invalidating everyone.\r\n                console.warn(\"Error fetching changed device list\", e);\r\n                this._deviceList.invalidateAllDeviceLists();\r\n            }\r\n        } else {\r\n            // otherwise, we have to invalidate all devices for all users we\r\n            // are tracking.\r\n            console.log(\"Completed first initialsync; invalidating all \" +\r\n                        \"device list caches\");\r\n            this._deviceList.invalidateAllDeviceLists();\r\n        }\r\n    }\r\n\r\n    // we can now store our sync token so that we can get an update on\r\n    // restart rather than having to invalidate everyone.\r\n    //\r\n    // (we don't really need to do this on every sync - we could just\r\n    // do it periodically)\r\n    this._sessionStore.storeEndToEndDeviceSyncToken(nextSyncToken);\r\n\r\n    // catch up on any new devices we got told about during the sync.\r\n    this._deviceList.lastKnownSyncToken = nextSyncToken;\r\n    this._deviceList.refreshOutdatedDeviceLists();\r\n\r\n    // we don't start uploading one-time keys until we've caught up with\r\n    // to-device messages, to help us avoid throwing away one-time-keys that we\r\n    // are about to receive messages for\r\n    // (https://github.com/vector-im/riot-web/issues/2782).\r\n    if (!syncData.catchingUp) {\r\n        _maybeUploadOneTimeKeys(this);\r\n        this._processReceivedRoomKeyRequests();\r\n    }\r\n};\r\n\r\n/**\r\n * Ask the server which users have new devices since a given token,\r\n * and invalidate them\r\n *\r\n * @param {String} oldSyncToken\r\n * @param {String} lastKnownSyncToken\r\n *\r\n * Returns a Promise which resolves once the query is complete. Rejects if the\r\n *   keyChange query fails.\r\n */\r\nCrypto.prototype._invalidateDeviceListsSince = async function(\r\n    oldSyncToken, lastKnownSyncToken,\r\n) {\r\n    const r = await this._baseApis.getKeyChanges(\r\n        oldSyncToken, lastKnownSyncToken,\r\n    );\r\n\r\n    console.log(\"got key changes since\", oldSyncToken, \":\", r);\r\n\r\n    await this.handleDeviceListChanges(r);\r\n};\r\n\r\n/**\r\n * Get a list of the e2e-enabled rooms we are members of\r\n *\r\n * @returns {module:models.Room[]}\r\n */\r\nCrypto.prototype._getE2eRooms = function() {\r\n    return this._clientStore.getRooms().filter((room) => {\r\n        // check for rooms with encryption enabled\r\n        const alg = this._roomEncryptors[room.roomId];\r\n        if (!alg) {\r\n            return false;\r\n        }\r\n\r\n        // ignore any rooms which we have left\r\n        const me = room.getMember(this._userId);\r\n        if (!me || (\r\n            me.membership !== \"join\" && me.membership !== \"invite\"\r\n        )) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    });\r\n};\r\n\r\n\r\nCrypto.prototype._onToDeviceEvent = function(event) {\r\n    try {\r\n        if (event.getType() == \"m.room_key\"\r\n            || event.getType() == \"m.forwarded_room_key\") {\r\n            this._onRoomKeyEvent(event);\r\n        } else if (event.getType() == \"m.room_key_request\") {\r\n            this._onRoomKeyRequestEvent(event);\r\n        } else if (event.isBeingDecrypted()) {\r\n            // once the event has been decrypted, try again\r\n            event.once('Event.decrypted', (ev) => {\r\n                this._onToDeviceEvent(ev);\r\n            });\r\n        }\r\n    } catch (e) {\r\n        console.error(\"Error handling toDeviceEvent:\", e);\r\n    }\r\n};\r\n\r\n/**\r\n * Handle a key event\r\n *\r\n * @private\r\n * @param {module:models/event.MatrixEvent} event key event\r\n */\r\nCrypto.prototype._onRoomKeyEvent = function(event) {\r\n    const content = event.getContent();\r\n\r\n    if (!content.room_id || !content.algorithm) {\r\n        console.error(\"key event is missing fields\");\r\n        return;\r\n    }\r\n\r\n    const alg = this._getRoomDecryptor(content.room_id, content.algorithm);\r\n    alg.onRoomKeyEvent(event);\r\n};\r\n\r\n/**\r\n * Handle a change in the membership state of a member of a room\r\n *\r\n * @private\r\n * @param {module:models/event.MatrixEvent} event  event causing the change\r\n * @param {module:models/room-member} member  user whose membership changed\r\n * @param {string=} oldMembership  previous membership\r\n */\r\nCrypto.prototype._onRoomMembership = function(event, member, oldMembership) {\r\n    // this event handler is registered on the *client* (as opposed to the room\r\n    // member itself), which means it is only called on changes to the *live*\r\n    // membership state (ie, it is not called when we back-paginate, nor when\r\n    // we load the state in the initialsync).\r\n    //\r\n    // Further, it is automatically registered and called when new members\r\n    // arrive in the room.\r\n\r\n    const roomId = member.roomId;\r\n\r\n    const alg = this._roomEncryptors[roomId];\r\n    if (!alg) {\r\n        // not encrypting in this room\r\n        return;\r\n    }\r\n\r\n    if (member.membership == 'join') {\r\n        console.log('Join event for ' + member.userId + ' in ' + roomId);\r\n        // make sure we are tracking the deviceList for this user\r\n        this._deviceList.startTrackingDeviceList(member.userId);\r\n    }\r\n\r\n    alg.onRoomMembership(event, member, oldMembership);\r\n};\r\n\r\n\r\n/**\r\n * Called when we get an m.room_key_request event.\r\n *\r\n * @private\r\n * @param {module:models/event.MatrixEvent} event key request event\r\n */\r\nCrypto.prototype._onRoomKeyRequestEvent = function(event) {\r\n    const content = event.getContent();\r\n    if (content.action === \"request\") {\r\n        // Queue it up for now, because they tend to arrive before the room state\r\n        // events at initial sync, and we want to see if we know anything about the\r\n        // room before passing them on to the app.\r\n        const req = new IncomingRoomKeyRequest(event);\r\n        this._receivedRoomKeyRequests.push(req);\r\n    } else if (content.action === \"request_cancellation\") {\r\n        const req = new IncomingRoomKeyRequestCancellation(event);\r\n        this._receivedRoomKeyRequestCancellations.push(req);\r\n    }\r\n};\r\n\r\n/**\r\n * Process any m.room_key_request events which were queued up during the\r\n * current sync.\r\n *\r\n * @private\r\n */\r\nCrypto.prototype._processReceivedRoomKeyRequests = async function() {\r\n    if (this._processingRoomKeyRequests) {\r\n        // we're still processing last time's requests; keep queuing new ones\r\n        // up for now.\r\n        return;\r\n    }\r\n    this._processingRoomKeyRequests = true;\r\n\r\n    try {\r\n        // we need to grab and clear the queues in the synchronous bit of this method,\r\n        // so that we don't end up racing with the next /sync.\r\n        const requests = this._receivedRoomKeyRequests;\r\n        this._receivedRoomKeyRequests = [];\r\n        const cancellations = this._receivedRoomKeyRequestCancellations;\r\n        this._receivedRoomKeyRequestCancellations = [];\r\n\r\n        // Process all of the requests, *then* all of the cancellations.\r\n        //\r\n        // This makes sure that if we get a request and its cancellation in the\r\n        // same /sync result, then we process the request before the\r\n        // cancellation (and end up with a cancelled request), rather than the\r\n        // cancellation before the request (and end up with an outstanding\r\n        // request which should have been cancelled.)\r\n        await Promise.map(\r\n            requests, (req) =>\r\n                this._processReceivedRoomKeyRequest(req),\r\n        );\r\n        await Promise.map(\r\n            cancellations, (cancellation) =>\r\n                this._processReceivedRoomKeyRequestCancellation(cancellation),\r\n        );\r\n    } catch (e) {\r\n        console.error(`Error processing room key requsts: ${e}`);\r\n    } finally {\r\n        this._processingRoomKeyRequests = false;\r\n    }\r\n};\r\n\r\n/**\r\n * Helper for processReceivedRoomKeyRequests\r\n *\r\n * @param {IncomingRoomKeyRequest} req\r\n */\r\nCrypto.prototype._processReceivedRoomKeyRequest = async function(req) {\r\n    const userId = req.userId;\r\n    const deviceId = req.deviceId;\r\n\r\n    const body = req.requestBody;\r\n    const roomId = body.room_id;\r\n    const alg = body.algorithm;\r\n\r\n    console.log(`m.room_key_request from ${userId}:${deviceId}` +\r\n                ` for ${roomId} / ${body.session_id} (id ${req.requestId})`);\r\n\r\n    if (userId !== this._userId) {\r\n        // TODO: determine if we sent this device the keys already: in\r\n        // which case we can do so again.\r\n        console.log(\"Ignoring room key request from other user for now\");\r\n        return;\r\n    }\r\n\r\n    // todo: should we queue up requests we don't yet have keys for,\r\n    // in case they turn up later?\r\n\r\n    // if we don't have a decryptor for this room/alg, we don't have\r\n    // the keys for the requested events, and can drop the requests.\r\n    if (!this._roomDecryptors[roomId]) {\r\n        console.log(`room key request for unencrypted room ${roomId}`);\r\n        return;\r\n    }\r\n\r\n    const decryptor = this._roomDecryptors[roomId][alg];\r\n    if (!decryptor) {\r\n        console.log(`room key request for unknown alg ${alg} in room ${roomId}`);\r\n        return;\r\n    }\r\n\r\n    if (!await decryptor.hasKeysForKeyRequest(req)) {\r\n        console.log(\r\n            `room key request for unknown session ${roomId} / ` +\r\n                body.session_id,\r\n        );\r\n        return;\r\n    }\r\n\r\n    req.share = () => {\r\n        decryptor.shareKeysWithDevice(req);\r\n    };\r\n\r\n    // if the device is is verified already, share the keys\r\n    const device = this._deviceList.getStoredDevice(userId, deviceId);\r\n    if (device && device.isVerified()) {\r\n        console.log('device is already verified: sharing keys');\r\n        req.share();\r\n        return;\r\n    }\r\n\r\n    this.emit(\"crypto.roomKeyRequest\", req);\r\n};\r\n\r\n\r\n/**\r\n * Helper for processReceivedRoomKeyRequests\r\n *\r\n * @param {IncomingRoomKeyRequestCancellation} cancellation\r\n */\r\nCrypto.prototype._processReceivedRoomKeyRequestCancellation = async function(\r\n    cancellation,\r\n) {\r\n    console.log(\r\n        `m.room_key_request cancellation for ${cancellation.userId}:` +\r\n            `${cancellation.deviceId} (id ${cancellation.requestId})`,\r\n    );\r\n\r\n    // we should probably only notify the app of cancellations we told it\r\n    // about, but we don't currently have a record of that, so we just pass\r\n    // everything through.\r\n    this.emit(\"crypto.roomKeyRequestCancellation\", cancellation);\r\n};\r\n\r\n/**\r\n * Get a decryptor for a given room and algorithm.\r\n *\r\n * If we already have a decryptor for the given room and algorithm, return\r\n * it. Otherwise try to instantiate it.\r\n *\r\n * @private\r\n *\r\n * @param {string?} roomId   room id for decryptor. If undefined, a temporary\r\n * decryptor is instantiated.\r\n *\r\n * @param {string} algorithm  crypto algorithm\r\n *\r\n * @return {module:crypto.algorithms.base.DecryptionAlgorithm}\r\n *\r\n * @raises {module:crypto.algorithms.DecryptionError} if the algorithm is\r\n * unknown\r\n */\r\nCrypto.prototype._getRoomDecryptor = function(roomId, algorithm) {\r\n    let decryptors;\r\n    let alg;\r\n\r\n    roomId = roomId || null;\r\n    if (roomId) {\r\n        decryptors = this._roomDecryptors[roomId];\r\n        if (!decryptors) {\r\n            this._roomDecryptors[roomId] = decryptors = {};\r\n        }\r\n\r\n        alg = decryptors[algorithm];\r\n        if (alg) {\r\n            return alg;\r\n        }\r\n    }\r\n\r\n    const AlgClass = algorithms.DECRYPTION_CLASSES[algorithm];\r\n    if (!AlgClass) {\r\n        throw new algorithms.DecryptionError(\r\n            'Unknown encryption algorithm \"' + algorithm + '\".',\r\n        );\r\n    }\r\n    alg = new AlgClass({\r\n        userId: this._userId,\r\n        crypto: this,\r\n        olmDevice: this._olmDevice,\r\n        baseApis: this._baseApis,\r\n        roomId: roomId,\r\n    });\r\n\r\n    if (decryptors) {\r\n        decryptors[algorithm] = alg;\r\n    }\r\n    return alg;\r\n};\r\n\r\n\r\n/**\r\n * sign the given object with our ed25519 key\r\n *\r\n * @param {Object} obj  Object to which we will add a 'signatures' property\r\n */\r\nCrypto.prototype._signObject = async function(obj) {\r\n    const sigs = {};\r\n    sigs[this._userId] = {};\r\n    sigs[this._userId][\"ed25519:\" + this._deviceId] =\r\n        await this._olmDevice.sign(anotherjson.stringify(obj));\r\n    obj.signatures = sigs;\r\n};\r\n\r\n\r\n/**\r\n * The parameters of a room key request. The details of the request may\r\n * vary with the crypto algorithm, but the management and storage layers for\r\n * outgoing requests expect it to have 'room_id' and 'session_id' properties.\r\n *\r\n * @typedef {Object} RoomKeyRequestBody\r\n */\r\n\r\n/**\r\n * Represents a received m.room_key_request event\r\n *\r\n * @property {string} userId    user requesting the key\r\n * @property {string} deviceId  device requesting the key\r\n * @property {string} requestId unique id for the request\r\n * @property {module:crypto~RoomKeyRequestBody} requestBody\r\n * @property {function()} share  callback which, when called, will ask\r\n *    the relevant crypto algorithm implementation to share the keys for\r\n *    this request.\r\n */\r\nclass IncomingRoomKeyRequest {\r\n    constructor(event) {\r\n        const content = event.getContent();\r\n\r\n        this.userId = event.getSender();\r\n        this.deviceId = content.requesting_device_id;\r\n        this.requestId = content.request_id;\r\n        this.requestBody = content.body || {};\r\n        this.share = () => {\r\n            throw new Error(\"don't know how to share keys for this request yet\");\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Represents a received m.room_key_request cancellation\r\n *\r\n * @property {string} userId    user requesting the cancellation\r\n * @property {string} deviceId  device requesting the cancellation\r\n * @property {string} requestId unique id for the request to be cancelled\r\n */\r\nclass IncomingRoomKeyRequestCancellation {\r\n    constructor(event) {\r\n        const content = event.getContent();\r\n\r\n        this.userId = event.getSender();\r\n        this.deviceId = content.requesting_device_id;\r\n        this.requestId = content.request_id;\r\n    }\r\n}\r\n\r\n/**\r\n * The result of a (successful) call to decryptEvent.\r\n *\r\n * @typedef {Object} EventDecryptionResult\r\n *\r\n * @property {Object} clearEvent The plaintext payload for the event\r\n *     (typically containing <tt>type</tt> and <tt>content</tt> fields).\r\n *\r\n * @property {?string} senderCurve25519Key Key owned by the sender of this\r\n *    event.  See {@link module:models/event.MatrixEvent#getSenderKey}.\r\n *\r\n * @property {?string} claimedEd25519Key ed25519 key claimed by the sender of\r\n *    this event. See\r\n *    {@link module:models/event.MatrixEvent#getClaimedEd25519Key}.\r\n *\r\n * @property {?Array<string>} forwardingCurve25519KeyChain list of curve25519\r\n *     keys involved in telling us about the senderCurve25519Key and\r\n *     claimedEd25519Key. See\r\n *     {@link module:models/event.MatrixEvent#getForwardingCurve25519KeyChain}.\r\n */\r\n\r\n/**\r\n * Fires when we receive a room key request\r\n *\r\n * @event module:client~MatrixClient#\"crypto.roomKeyRequest\"\r\n * @param {module:crypto~IncomingRoomKeyRequest} req  request details\r\n */\r\n\r\n/**\r\n * Fires when we receive a room key request cancellation\r\n *\r\n * @event module:client~MatrixClient#\"crypto.roomKeyRequestCancellation\"\r\n * @param {module:crypto~IncomingRoomKeyRequestCancellation} req\r\n */\r\n\r\n/** */\r\nmodule.exports = Crypto;\r\n"]}