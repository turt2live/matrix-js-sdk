{"version":3,"sources":["../../../src/crypto/store/indexeddb-crypto-store-backend.js"],"names":["upgradeDatabase","VERSION","Backend","db","_db","onversionchange","ev","console","log","_dbName","close","request","requestBody","deferred","defer","txn","transaction","onerror","reject","_getOutgoingRoomKeyRequest","existing","room_id","session_id","resolve","store","objectStore","add","onsuccess","promise","callback","idx","index","cursorReq","openCursor","cursor","target","result","value","deepCompare","continue","wantedStates","length","stateIndex","wantedState","source","promiseifyTxn","then","requestId","expectedState","updates","data","state","warn","update","delete","oldVersion","createDatabase","outgoingRoomKeyRequestsStore","createObjectStore","keyPath","createIndex","oncomplete"],"mappings":"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","file":"indexeddb-crypto-store-backend.js","sourcesContent":["import Promise from 'bluebird';\r\nimport utils from '../../utils';\r\n\r\nexport const VERSION = 1;\r\n\r\n/**\r\n * Implementation of a CryptoStore which is backed by an existing\r\n * IndexedDB connection. Generally you want IndexedDBCryptoStore\r\n * which connects to the database and defers to one of these.\r\n *\r\n * @implements {module:crypto/store/base~CryptoStore}\r\n */\r\nexport class Backend {\r\n    /**\r\n     * @param {IDBDatabase} db\r\n     */\r\n    constructor(db) {\r\n        this._db = db;\r\n\r\n        // make sure we close the db on `onversionchange` - otherwise\r\n        // attempts to delete the database will block (and subsequent\r\n        // attempts to re-create it will also block).\r\n        db.onversionchange = (ev) => {\r\n            console.log(`versionchange for indexeddb ${this._dbName}: closing`);\r\n            db.close();\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Look for an existing outgoing room key request, and if none is found,\r\n     * add a new one\r\n     *\r\n     * @param {module:crypto/store/base~OutgoingRoomKeyRequest} request\r\n     *\r\n     * @returns {Promise} resolves to\r\n     *    {@link module:crypto/store/base~OutgoingRoomKeyRequest}: either the\r\n     *    same instance as passed in, or the existing one.\r\n     */\r\n    getOrAddOutgoingRoomKeyRequest(request) {\r\n        const requestBody = request.requestBody;\r\n\r\n        const deferred = Promise.defer();\r\n        const txn = this._db.transaction(\"outgoingRoomKeyRequests\", \"readwrite\");\r\n        txn.onerror = deferred.reject;\r\n\r\n        // first see if we already have an entry for this request.\r\n        this._getOutgoingRoomKeyRequest(txn, requestBody, (existing) => {\r\n            if (existing) {\r\n                // this entry matches the request - return it.\r\n                console.log(\r\n                    `already have key request outstanding for ` +\r\n                        `${requestBody.room_id} / ${requestBody.session_id}: ` +\r\n                        `not sending another`,\r\n                );\r\n                deferred.resolve(existing);\r\n                return;\r\n            }\r\n\r\n            // we got to the end of the list without finding a match\r\n            // - add the new request.\r\n            console.log(\r\n                `enqueueing key request for ${requestBody.room_id} / ` +\r\n                    requestBody.session_id,\r\n            );\r\n            const store = txn.objectStore(\"outgoingRoomKeyRequests\");\r\n            store.add(request);\r\n            txn.onsuccess = () => { deferred.resolve(request); };\r\n        });\r\n\r\n        return deferred.promise;\r\n    }\r\n\r\n    /**\r\n     * Look for an existing room key request\r\n     *\r\n     * @param {module:crypto~RoomKeyRequestBody} requestBody\r\n     *    existing request to look for\r\n     *\r\n     * @return {Promise} resolves to the matching\r\n     *    {@link module:crypto/store/base~OutgoingRoomKeyRequest}, or null if\r\n     *    not found\r\n     */\r\n    getOutgoingRoomKeyRequest(requestBody) {\r\n        const deferred = Promise.defer();\r\n\r\n        const txn = this._db.transaction(\"outgoingRoomKeyRequests\", \"readonly\");\r\n        txn.onerror = deferred.reject;\r\n\r\n        this._getOutgoingRoomKeyRequest(txn, requestBody, (existing) => {\r\n            deferred.resolve(existing);\r\n        });\r\n        return deferred.promise;\r\n    }\r\n\r\n    /**\r\n     * look for an existing room key request in the db\r\n     *\r\n     * @private\r\n     * @param {IDBTransaction} txn  database transaction\r\n     * @param {module:crypto~RoomKeyRequestBody} requestBody\r\n     *    existing request to look for\r\n     * @param {Function} callback  function to call with the results of the\r\n     *    search. Either passed a matching\r\n     *    {@link module:crypto/store/base~OutgoingRoomKeyRequest}, or null if\r\n     *    not found.\r\n     */\r\n    _getOutgoingRoomKeyRequest(txn, requestBody, callback) {\r\n        const store = txn.objectStore(\"outgoingRoomKeyRequests\");\r\n\r\n        const idx = store.index(\"session\");\r\n        const cursorReq = idx.openCursor([\r\n            requestBody.room_id,\r\n            requestBody.session_id,\r\n        ]);\r\n\r\n        cursorReq.onsuccess = (ev) => {\r\n            const cursor = ev.target.result;\r\n            if(!cursor) {\r\n                // no match found\r\n                callback(null);\r\n                return;\r\n            }\r\n\r\n            const existing = cursor.value;\r\n\r\n            if (utils.deepCompare(existing.requestBody, requestBody)) {\r\n                // got a match\r\n                callback(existing);\r\n                return;\r\n            }\r\n\r\n            // look at the next entry in the index\r\n            cursor.continue();\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Look for room key requests by state\r\n     *\r\n     * @param {Array<Number>} wantedStates list of acceptable states\r\n     *\r\n     * @return {Promise} resolves to the a\r\n     *    {@link module:crypto/store/base~OutgoingRoomKeyRequest}, or null if\r\n     *    there are no pending requests in those states. If there are multiple\r\n     *    requests in those states, an arbitrary one is chosen.\r\n     */\r\n    getOutgoingRoomKeyRequestByState(wantedStates) {\r\n        if (wantedStates.length === 0) {\r\n            return Promise.resolve(null);\r\n        }\r\n\r\n        // this is a bit tortuous because we need to make sure we do the lookup\r\n        // in a single transaction, to avoid having a race with the insertion\r\n        // code.\r\n\r\n        // index into the wantedStates array\r\n        let stateIndex = 0;\r\n        let result;\r\n\r\n        function onsuccess(ev) {\r\n            const cursor = ev.target.result;\r\n            if (cursor) {\r\n                // got a match\r\n                result = cursor.value;\r\n                return;\r\n            }\r\n\r\n            // try the next state in the list\r\n            stateIndex++;\r\n            if (stateIndex >= wantedStates.length) {\r\n                // no matches\r\n                return;\r\n            }\r\n\r\n            const wantedState = wantedStates[stateIndex];\r\n            const cursorReq = ev.target.source.openCursor(wantedState);\r\n            cursorReq.onsuccess = onsuccess;\r\n        }\r\n\r\n        const txn = this._db.transaction(\"outgoingRoomKeyRequests\", \"readonly\");\r\n        const store = txn.objectStore(\"outgoingRoomKeyRequests\");\r\n\r\n        const wantedState = wantedStates[stateIndex];\r\n        const cursorReq = store.index(\"state\").openCursor(wantedState);\r\n        cursorReq.onsuccess = onsuccess;\r\n\r\n        return promiseifyTxn(txn).then(() => result);\r\n    }\r\n\r\n    /**\r\n     * Look for an existing room key request by id and state, and update it if\r\n     * found\r\n     *\r\n     * @param {string} requestId      ID of request to update\r\n     * @param {number} expectedState  state we expect to find the request in\r\n     * @param {Object} updates        name/value map of updates to apply\r\n     *\r\n     * @returns {Promise} resolves to\r\n     *    {@link module:crypto/store/base~OutgoingRoomKeyRequest}\r\n     *    updated request, or null if no matching row was found\r\n     */\r\n    updateOutgoingRoomKeyRequest(requestId, expectedState, updates) {\r\n        let result = null;\r\n\r\n        function onsuccess(ev) {\r\n            const cursor = ev.target.result;\r\n            if (!cursor) {\r\n                return;\r\n            }\r\n            const data = cursor.value;\r\n            if (data.state != expectedState) {\r\n                console.warn(\r\n                    `Cannot update room key request from ${expectedState} ` +\r\n                    `as it was already updated to ${data.state}`,\r\n                );\r\n                return;\r\n            }\r\n            Object.assign(data, updates);\r\n            cursor.update(data);\r\n            result = data;\r\n        }\r\n\r\n        const txn = this._db.transaction(\"outgoingRoomKeyRequests\", \"readwrite\");\r\n        const cursorReq = txn.objectStore(\"outgoingRoomKeyRequests\")\r\n                  .openCursor(requestId);\r\n        cursorReq.onsuccess = onsuccess;\r\n        return promiseifyTxn(txn).then(() => result);\r\n    }\r\n\r\n    /**\r\n     * Look for an existing room key request by id and state, and delete it if\r\n     * found\r\n     *\r\n     * @param {string} requestId      ID of request to update\r\n     * @param {number} expectedState  state we expect to find the request in\r\n     *\r\n     * @returns {Promise} resolves once the operation is completed\r\n     */\r\n    deleteOutgoingRoomKeyRequest(requestId, expectedState) {\r\n        const txn = this._db.transaction(\"outgoingRoomKeyRequests\", \"readwrite\");\r\n        const cursorReq = txn.objectStore(\"outgoingRoomKeyRequests\")\r\n                  .openCursor(requestId);\r\n        cursorReq.onsuccess = (ev) => {\r\n            const cursor = ev.target.result;\r\n            if (!cursor) {\r\n                return;\r\n            }\r\n            const data = cursor.value;\r\n            if (data.state != expectedState) {\r\n                console.warn(\r\n                    `Cannot delete room key request in state ${data.state} `\r\n                        + `(expected ${expectedState})`,\r\n                );\r\n                return;\r\n            }\r\n            cursor.delete();\r\n        };\r\n        return promiseifyTxn(txn);\r\n    }\r\n}\r\n\r\nexport function upgradeDatabase(db, oldVersion) {\r\n    console.log(\r\n        `Upgrading IndexedDBCryptoStore from version ${oldVersion}`\r\n            + ` to ${VERSION}`,\r\n    );\r\n    if (oldVersion < 1) { // The database did not previously exist.\r\n        createDatabase(db);\r\n    }\r\n    // Expand as needed.\r\n}\r\n\r\nfunction createDatabase(db) {\r\n    const outgoingRoomKeyRequestsStore =\r\n        db.createObjectStore(\"outgoingRoomKeyRequests\", { keyPath: \"requestId\" });\r\n\r\n    // we assume that the RoomKeyRequestBody will have room_id and session_id\r\n    // properties, to make the index efficient.\r\n    outgoingRoomKeyRequestsStore.createIndex(\"session\",\r\n        [\"requestBody.room_id\", \"requestBody.session_id\"],\r\n    );\r\n\r\n    outgoingRoomKeyRequestsStore.createIndex(\"state\", \"state\");\r\n}\r\n\r\nfunction promiseifyTxn(txn) {\r\n    return new Promise((resolve, reject) => {\r\n        txn.oncomplete = resolve;\r\n        txn.onerror = reject;\r\n    });\r\n}\r\n"]}