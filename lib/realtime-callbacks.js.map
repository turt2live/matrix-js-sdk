{"version":3,"sources":["../src/realtime-callbacks.js"],"names":["TIMER_CHECK_PERIOD_MS","_count","_realCallbackKey","_callbackList","debuglog","module","exports","setNow","f","_now","Date","now","setTimeout","func","delayMs","params","Array","prototype","slice","call","arguments","runAt","key","data","idx","binarySearch","el","splice","_scheduleRealCallback","clearTimeout","length","i","cb","global","first","Math","min","_runCallbacks","callbacksToRun","shift","push","apply","e","console","error","stack","array","max","mid","res"],"mappings":"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","file":"realtime-callbacks.js","sourcesContent":["/*\r\nCopyright 2016 OpenMarket Ltd\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n*/\r\n\r\n/* A re-implementation of the javascript callback functions (setTimeout,\r\n * clearTimeout; setInterval and clearInterval are not yet implemented) which\r\n * try to improve handling of large clock jumps (as seen when\r\n * suspending/resuming the system).\r\n *\r\n * In particular, if a timeout would have fired while the system was suspended,\r\n * it will instead fire as soon as possible after resume.\r\n */\r\n\r\n\"use strict\";\r\n\r\n// we schedule a callback at least this often, to check if we've missed out on\r\n// some wall-clock time due to being suspended.\r\nconst TIMER_CHECK_PERIOD_MS = 1000;\r\n\r\n// counter, for making up ids to return from setTimeout\r\nlet _count = 0;\r\n\r\n// the key for our callback with the real global.setTimeout\r\nlet _realCallbackKey;\r\n\r\n// a sorted list of the callbacks to be run.\r\n// each is an object with keys [runAt, func, params, key].\r\nconst _callbackList = [];\r\n\r\n// var debuglog = console.log.bind(console);\r\nconst debuglog = function() {};\r\n\r\n/**\r\n * Replace the function used by this module to get the current time.\r\n *\r\n * Intended for use by the unit tests.\r\n *\r\n * @param {function} f function which should return a millisecond counter\r\n *\r\n * @internal\r\n */\r\nmodule.exports.setNow = function(f) {\r\n    _now = f || Date.now;\r\n};\r\nlet _now = Date.now;\r\n\r\n/**\r\n * reimplementation of window.setTimeout, which will call the callback if\r\n * the wallclock time goes past the deadline.\r\n *\r\n * @param {function} func   callback to be called after a delay\r\n * @param {Number} delayMs  number of milliseconds to delay by\r\n *\r\n * @return {Number} an identifier for this callback, which may be passed into\r\n *                   clearTimeout later.\r\n */\r\nmodule.exports.setTimeout = function(func, delayMs) {\r\n    delayMs = delayMs || 0;\r\n    if (delayMs < 0) {\r\n        delayMs = 0;\r\n    }\r\n\r\n    const params = Array.prototype.slice.call(arguments, 2);\r\n    const runAt = _now() + delayMs;\r\n    const key = _count++;\r\n    debuglog(\"setTimeout: scheduling cb\", key, \"at\", runAt,\r\n             \"(delay\", delayMs, \")\");\r\n    const data = {\r\n        runAt: runAt,\r\n        func: func,\r\n        params: params,\r\n        key: key,\r\n    };\r\n\r\n    // figure out where it goes in the list\r\n    const idx = binarySearch(\r\n        _callbackList, function(el) {\r\n            return el.runAt - runAt;\r\n        },\r\n    );\r\n\r\n    _callbackList.splice(idx, 0, data);\r\n    _scheduleRealCallback();\r\n\r\n    return key;\r\n};\r\n\r\n/**\r\n * reimplementation of window.clearTimeout, which mirrors setTimeout\r\n *\r\n * @param {Number} key   result from an earlier setTimeout call\r\n */\r\nmodule.exports.clearTimeout = function(key) {\r\n    if (_callbackList.length === 0) {\r\n        return;\r\n    }\r\n\r\n    // remove the element from the list\r\n    let i;\r\n    for (i = 0; i < _callbackList.length; i++) {\r\n        const cb = _callbackList[i];\r\n        if (cb.key == key) {\r\n            _callbackList.splice(i, 1);\r\n            break;\r\n        }\r\n    }\r\n\r\n    // iff it was the first one in the list, reschedule our callback.\r\n    if (i === 0) {\r\n        _scheduleRealCallback();\r\n    }\r\n};\r\n\r\n// use the real global.setTimeout to schedule a callback to _runCallbacks.\r\nfunction _scheduleRealCallback() {\r\n    if (_realCallbackKey) {\r\n        global.clearTimeout(_realCallbackKey);\r\n    }\r\n\r\n    const first = _callbackList[0];\r\n\r\n    if (!first) {\r\n        debuglog(\"_scheduleRealCallback: no more callbacks, not rescheduling\");\r\n        return;\r\n    }\r\n\r\n    const now = _now();\r\n    const delayMs = Math.min(first.runAt - now, TIMER_CHECK_PERIOD_MS);\r\n\r\n    debuglog(\"_scheduleRealCallback: now:\", now, \"delay:\", delayMs);\r\n    _realCallbackKey = global.setTimeout(_runCallbacks, delayMs);\r\n}\r\n\r\nfunction _runCallbacks() {\r\n    let cb;\r\n    const now = _now();\r\n    debuglog(\"_runCallbacks: now:\", now);\r\n\r\n    // get the list of things to call\r\n    const callbacksToRun = [];\r\n    while (true) {\r\n        const first = _callbackList[0];\r\n        if (!first || first.runAt > now) {\r\n            break;\r\n        }\r\n        cb = _callbackList.shift();\r\n        debuglog(\"_runCallbacks: popping\", cb.key);\r\n        callbacksToRun.push(cb);\r\n    }\r\n\r\n    // reschedule the real callback before running our functions, to\r\n    // keep the codepaths the same whether or not our functions\r\n    // register their own setTimeouts.\r\n    _scheduleRealCallback();\r\n\r\n    for (let i = 0; i < callbacksToRun.length; i++) {\r\n        cb = callbacksToRun[i];\r\n        try {\r\n            cb.func.apply(global, cb.params);\r\n        } catch (e) {\r\n            console.error(\"Uncaught exception in callback function\",\r\n                          e.stack || e);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/* search in a sorted array.\r\n *\r\n * returns the index of the last element for which func returns\r\n * greater than zero, or array.length if no such element exists.\r\n */\r\nfunction binarySearch(array, func) {\r\n    // min is inclusive, max exclusive.\r\n    let min = 0,\r\n        max = array.length;\r\n\r\n    while (min < max) {\r\n        const mid = (min + max) >> 1;\r\n        const res = func(array[mid]);\r\n        if (res > 0) {\r\n            // the element at 'mid' is too big; set it as the new max.\r\n            max = mid;\r\n        } else {\r\n            // the element at 'mid' is too small. 'min' is inclusive, so +1.\r\n            min = mid + 1;\r\n        }\r\n    }\r\n    // presumably, min==max now.\r\n    return min;\r\n}\r\n"]}