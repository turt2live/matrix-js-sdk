{"version":3,"sources":["../../src/models/room-state.js"],"names":["EventEmitter","require","utils","RoomMember","RoomState","roomId","members","events","paginationToken","_sentinels","_updateModifiedTime","_displayNameToUserIds","_userIdsToDisplayNames","_tokenToInvite","inherits","prototype","getMembers","values","getMember","userId","getSentinelMember","getStateEvents","eventType","stateKey","undefined","event","setStateEvents","stateEvents","self","forEach","getRoomId","isState","getType","getStateKey","_updateDisplayNameCache","getContent","displayname","_updateThirdPartyTokenCache","emit","membership","avatar_url","getPrevContent","member","sentinel","roomMember","setMembershipEvent","pwrLvlEvent","setPowerLevelEvent","setTypingEvent","getInviteForThreePidToken","token","_modified","Date","now","getLastModifiedTime","getUserIdsWithDisplayName","displayName","maySendRedactionForEvent","mxEvent","status","isRedacted","getSender","_hasSufficientPowerLevelFor","powerLevel","action","powerLevelsEvent","powerLevels","requiredLevel","maySendMessage","_maySendEventOfType","maySendEvent","mayClientSendStateEvent","stateEventType","cli","isGuest","maySendStateEvent","credentials","state","power_levels_event","power_levels","events_levels","state_default","events_default","required_level","module","exports","roomState","memberEvent","third_party_invite","signed","threePidInvite","oldName","existingUserIds","i","length","splice","push"],"mappings":"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","file":"room-state.js","sourcesContent":["/*\r\nCopyright 2015, 2016 OpenMarket Ltd\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n*/\r\n\"use strict\";\r\n/**\r\n * @module models/room-state\r\n */\r\nconst EventEmitter = require(\"events\").EventEmitter;\r\n\r\nconst utils = require(\"../utils\");\r\nconst RoomMember = require(\"./room-member\");\r\n\r\n/**\r\n * Construct room state.\r\n * @constructor\r\n * @param {?string} roomId Optional. The ID of the room which has this state.\r\n * If none is specified it just tracks paginationTokens, useful for notifTimelineSet\r\n * @prop {Object.<string, RoomMember>} members The room member dictionary, keyed\r\n * on the user's ID.\r\n * @prop {Object.<string, Object.<string, MatrixEvent>>} events The state\r\n * events dictionary, keyed on the event type and then the state_key value.\r\n * @prop {string} paginationToken The pagination token for this state.\r\n */\r\nfunction RoomState(roomId) {\r\n    this.roomId = roomId;\r\n    this.members = {\r\n        // userId: RoomMember\r\n    };\r\n    this.events = {\r\n        // eventType: { stateKey: MatrixEvent }\r\n    };\r\n    this.paginationToken = null;\r\n\r\n    this._sentinels = {\r\n        // userId: RoomMember\r\n    };\r\n    this._updateModifiedTime();\r\n    this._displayNameToUserIds = {};\r\n    this._userIdsToDisplayNames = {};\r\n    this._tokenToInvite = {}; // 3pid invite state_key to m.room.member invite\r\n}\r\nutils.inherits(RoomState, EventEmitter);\r\n\r\n/**\r\n * Get all RoomMembers in this room.\r\n * @return {Array<RoomMember>} A list of RoomMembers.\r\n */\r\nRoomState.prototype.getMembers = function() {\r\n    return utils.values(this.members);\r\n};\r\n\r\n/**\r\n * Get a room member by their user ID.\r\n * @param {string} userId The room member's user ID.\r\n * @return {RoomMember} The member or null if they do not exist.\r\n */\r\nRoomState.prototype.getMember = function(userId) {\r\n    return this.members[userId] || null;\r\n};\r\n\r\n/**\r\n * Get a room member whose properties will not change with this room state. You\r\n * typically want this if you want to attach a RoomMember to a MatrixEvent which\r\n * may no longer be represented correctly by Room.currentState or Room.oldState.\r\n * The term 'sentinel' refers to the fact that this RoomMember is an unchanging\r\n * guardian for state at this particular point in time.\r\n * @param {string} userId The room member's user ID.\r\n * @return {RoomMember} The member or null if they do not exist.\r\n */\r\nRoomState.prototype.getSentinelMember = function(userId) {\r\n    return this._sentinels[userId] || null;\r\n};\r\n\r\n/**\r\n * Get state events from the state of the room.\r\n * @param {string} eventType The event type of the state event.\r\n * @param {string} stateKey Optional. The state_key of the state event. If\r\n * this is <code>undefined</code> then all matching state events will be\r\n * returned.\r\n * @return {MatrixEvent[]|MatrixEvent} A list of events if state_key was\r\n * <code>undefined</code>, else a single event (or null if no match found).\r\n */\r\nRoomState.prototype.getStateEvents = function(eventType, stateKey) {\r\n    if (!this.events[eventType]) {\r\n        // no match\r\n        return stateKey === undefined ? [] : null;\r\n    }\r\n    if (stateKey === undefined) { // return all values\r\n        return utils.values(this.events[eventType]);\r\n    }\r\n    const event = this.events[eventType][stateKey];\r\n    return event ? event : null;\r\n};\r\n\r\n/**\r\n * Add an array of one or more state MatrixEvents, overwriting\r\n * any existing state with the same {type, stateKey} tuple. Will fire\r\n * \"RoomState.events\" for every event added. May fire \"RoomState.members\"\r\n * if there are <code>m.room.member</code> events.\r\n * @param {MatrixEvent[]} stateEvents a list of state events for this room.\r\n * @fires module:client~MatrixClient#event:\"RoomState.members\"\r\n * @fires module:client~MatrixClient#event:\"RoomState.newMember\"\r\n * @fires module:client~MatrixClient#event:\"RoomState.events\"\r\n */\r\nRoomState.prototype.setStateEvents = function(stateEvents) {\r\n    const self = this;\r\n    this._updateModifiedTime();\r\n\r\n    // update the core event dict\r\n    utils.forEach(stateEvents, function(event) {\r\n        if (event.getRoomId() !== self.roomId) {\r\n            return;\r\n        }\r\n        if (!event.isState()) {\r\n            return;\r\n        }\r\n\r\n        if (self.events[event.getType()] === undefined) {\r\n            self.events[event.getType()] = {};\r\n        }\r\n        self.events[event.getType()][event.getStateKey()] = event;\r\n        if (event.getType() === \"m.room.member\") {\r\n            _updateDisplayNameCache(\r\n                self, event.getStateKey(), event.getContent().displayname,\r\n            );\r\n            _updateThirdPartyTokenCache(self, event);\r\n        }\r\n        self.emit(\"RoomState.events\", event, self);\r\n    });\r\n\r\n    // update higher level data structures. This needs to be done AFTER the\r\n    // core event dict as these structures may depend on other state events in\r\n    // the given array (e.g. disambiguating display names in one go to do both\r\n    // clashing names rather than progressively which only catches 1 of them).\r\n    utils.forEach(stateEvents, function(event) {\r\n        if (event.getRoomId() !== self.roomId) {\r\n            return;\r\n        }\r\n        if (!event.isState()) {\r\n            return;\r\n        }\r\n\r\n        if (event.getType() === \"m.room.member\") {\r\n            const userId = event.getStateKey();\r\n\r\n            // leave events apparently elide the displayname or avatar_url,\r\n            // so let's fake one up so that we don't leak user ids\r\n            // into the timeline\r\n            if (event.getContent().membership === \"leave\" ||\r\n                event.getContent().membership === \"ban\") {\r\n                event.getContent().avatar_url =\r\n                    event.getContent().avatar_url ||\r\n                    event.getPrevContent().avatar_url;\r\n                event.getContent().displayname =\r\n                    event.getContent().displayname ||\r\n                    event.getPrevContent().displayname;\r\n            }\r\n\r\n            let member = self.members[userId];\r\n            if (!member) {\r\n                member = new RoomMember(event.getRoomId(), userId);\r\n                self.emit(\"RoomState.newMember\", event, self, member);\r\n            }\r\n            // Add a new sentinel for this change. We apply the same\r\n            // operations to both sentinel and member rather than deep copying\r\n            // so we don't make assumptions about the properties of RoomMember\r\n            // (e.g. and manage to break it because deep copying doesn't do\r\n            // everything).\r\n            const sentinel = new RoomMember(event.getRoomId(), userId);\r\n            utils.forEach([member, sentinel], function(roomMember) {\r\n                roomMember.setMembershipEvent(event, self);\r\n                // this member may have a power level already, so set it.\r\n                const pwrLvlEvent = self.getStateEvents(\"m.room.power_levels\", \"\");\r\n                if (pwrLvlEvent) {\r\n                    roomMember.setPowerLevelEvent(pwrLvlEvent);\r\n                }\r\n            });\r\n\r\n            self._sentinels[userId] = sentinel;\r\n            self.members[userId] = member;\r\n            self.emit(\"RoomState.members\", event, self, member);\r\n        } else if (event.getType() === \"m.room.power_levels\") {\r\n            const members = utils.values(self.members);\r\n            utils.forEach(members, function(member) {\r\n                member.setPowerLevelEvent(event);\r\n                self.emit(\"RoomState.members\", event, self, member);\r\n            });\r\n        }\r\n    });\r\n};\r\n\r\n/**\r\n * Set the current typing event for this room.\r\n * @param {MatrixEvent} event The typing event\r\n */\r\nRoomState.prototype.setTypingEvent = function(event) {\r\n    utils.forEach(utils.values(this.members), function(member) {\r\n        member.setTypingEvent(event);\r\n    });\r\n};\r\n\r\n/**\r\n * Get the m.room.member event which has the given third party invite token.\r\n *\r\n * @param {string} token The token\r\n * @return {?MatrixEvent} The m.room.member event or null\r\n */\r\nRoomState.prototype.getInviteForThreePidToken = function(token) {\r\n    return this._tokenToInvite[token] || null;\r\n};\r\n\r\n/**\r\n * Update the last modified time to the current time.\r\n */\r\nRoomState.prototype._updateModifiedTime = function() {\r\n    this._modified = Date.now();\r\n};\r\n\r\n/**\r\n * Get the timestamp when this room state was last updated. This timestamp is\r\n * updated when this object has received new state events.\r\n * @return {number} The timestamp\r\n */\r\nRoomState.prototype.getLastModifiedTime = function() {\r\n    return this._modified;\r\n};\r\n\r\n/**\r\n * Get user IDs with the specified display name.\r\n * @param {string} displayName The display name to get user IDs from.\r\n * @return {string[]} An array of user IDs or an empty array.\r\n */\r\nRoomState.prototype.getUserIdsWithDisplayName = function(displayName) {\r\n    return this._displayNameToUserIds[displayName] || [];\r\n};\r\n\r\n/**\r\n * Returns true if userId is in room, event is not redacted and either sender of\r\n * mxEvent or has power level sufficient to redact events other than their own.\r\n * @param {MatrixEvent} mxEvent The event to test permission for\r\n * @param {string} userId The user ID of the user to test permission for\r\n * @return {boolean} true if the given used ID can redact given event\r\n */\r\nRoomState.prototype.maySendRedactionForEvent = function(mxEvent, userId) {\r\n    const member = this.getMember(userId);\r\n    if (!member || member.membership === 'leave') return false;\r\n\r\n    if (mxEvent.status || mxEvent.isRedacted()) return false;\r\n    if (mxEvent.getSender() === userId) return true;\r\n\r\n    return this._hasSufficientPowerLevelFor('redact', member.powerLevel);\r\n};\r\n\r\n/**\r\n * Returns true if the given power level is sufficient for action\r\n * @param {string} action The type of power level to check\r\n * @param {number} powerLevel The power level of the member\r\n * @return {boolean} true if the given power level is sufficient\r\n */\r\nRoomState.prototype._hasSufficientPowerLevelFor = function(action, powerLevel) {\r\n    const powerLevelsEvent = this.getStateEvents('m.room.power_levels', '');\r\n\r\n    let powerLevels = {};\r\n    if (powerLevelsEvent) {\r\n        powerLevels = powerLevelsEvent.getContent();\r\n    }\r\n\r\n    let requiredLevel = 50;\r\n    if (powerLevels[action] !== undefined) {\r\n        requiredLevel = powerLevels[action];\r\n    }\r\n\r\n    return powerLevel >= requiredLevel;\r\n};\r\n\r\n/**\r\n * Short-form for maySendEvent('m.room.message', userId)\r\n * @param {string} userId The user ID of the user to test permission for\r\n * @return {boolean} true if the given user ID should be permitted to send\r\n *                   message events into the given room.\r\n */\r\nRoomState.prototype.maySendMessage = function(userId) {\r\n    return this._maySendEventOfType('m.room.message', userId, false);\r\n};\r\n\r\n/**\r\n * Returns true if the given user ID has permission to send a normal\r\n * event of type `eventType` into this room.\r\n * @param {string} eventType The type of event to test\r\n * @param {string} userId The user ID of the user to test permission for\r\n * @return {boolean} true if the given user ID should be permitted to send\r\n *                        the given type of event into this room,\r\n *                        according to the room's state.\r\n */\r\nRoomState.prototype.maySendEvent = function(eventType, userId) {\r\n    return this._maySendEventOfType(eventType, userId, false);\r\n};\r\n\r\n/**\r\n * Returns true if the given MatrixClient has permission to send a state\r\n * event of type `stateEventType` into this room.\r\n * @param {string} stateEventType The type of state events to test\r\n * @param {MatrixClient} cli The client to test permission for\r\n * @return {boolean} true if the given client should be permitted to send\r\n *                        the given type of state event into this room,\r\n *                        according to the room's state.\r\n */\r\nRoomState.prototype.mayClientSendStateEvent = function(stateEventType, cli) {\r\n    if (cli.isGuest()) {\r\n        return false;\r\n    }\r\n    return this.maySendStateEvent(stateEventType, cli.credentials.userId);\r\n};\r\n\r\n/**\r\n * Returns true if the given user ID has permission to send a state\r\n * event of type `stateEventType` into this room.\r\n * @param {string} stateEventType The type of state events to test\r\n * @param {string} userId The user ID of the user to test permission for\r\n * @return {boolean} true if the given user ID should be permitted to send\r\n *                        the given type of state event into this room,\r\n *                        according to the room's state.\r\n */\r\nRoomState.prototype.maySendStateEvent = function(stateEventType, userId) {\r\n    return this._maySendEventOfType(stateEventType, userId, true);\r\n};\r\n\r\n/**\r\n * Returns true if the given user ID has permission to send a normal or state\r\n * event of type `eventType` into this room.\r\n * @param {string} eventType The type of event to test\r\n * @param {string} userId The user ID of the user to test permission for\r\n * @param {boolean} state If true, tests if the user may send a state\r\n                          event of this type. Otherwise tests whether\r\n                          they may send a regular event.\r\n * @return {boolean} true if the given user ID should be permitted to send\r\n *                        the given type of event into this room,\r\n *                        according to the room's state.\r\n */\r\nRoomState.prototype._maySendEventOfType = function(eventType, userId, state) {\r\n    const member = this.getMember(userId);\r\n    if (!member || member.membership == 'leave') {\r\n        return false;\r\n    }\r\n\r\n    const power_levels_event = this.getStateEvents('m.room.power_levels', '');\r\n\r\n    let power_levels;\r\n    let events_levels = {};\r\n\r\n    let state_default = 0;\r\n    let events_default = 0;\r\n    if (power_levels_event) {\r\n        power_levels = power_levels_event.getContent();\r\n        events_levels = power_levels.events || {};\r\n\r\n        if (power_levels.state_default !== undefined) {\r\n            state_default = power_levels.state_default;\r\n        } else {\r\n            state_default = 50;\r\n        }\r\n        if (power_levels.events_default !== undefined) {\r\n            events_default = power_levels.events_default;\r\n        }\r\n    }\r\n\r\n    let required_level = state ? state_default : events_default;\r\n    if (events_levels[eventType] !== undefined) {\r\n        required_level = events_levels[eventType];\r\n    }\r\n    return member.powerLevel >= required_level;\r\n};\r\n\r\n/**\r\n * The RoomState class.\r\n */\r\nmodule.exports = RoomState;\r\n\r\n\r\nfunction _updateThirdPartyTokenCache(roomState, memberEvent) {\r\n    if (!memberEvent.getContent().third_party_invite) {\r\n        return;\r\n    }\r\n    const token = (memberEvent.getContent().third_party_invite.signed || {}).token;\r\n    if (!token) {\r\n        return;\r\n    }\r\n    const threePidInvite = roomState.getStateEvents(\r\n        \"m.room.third_party_invite\", token,\r\n    );\r\n    if (!threePidInvite) {\r\n        return;\r\n    }\r\n    roomState._tokenToInvite[token] = memberEvent;\r\n}\r\n\r\nfunction _updateDisplayNameCache(roomState, userId, displayName) {\r\n    const oldName = roomState._userIdsToDisplayNames[userId];\r\n    delete roomState._userIdsToDisplayNames[userId];\r\n    if (oldName) {\r\n        // Remove the old name from the cache.\r\n        // We clobber the user_id > name lookup but the name -> [user_id] lookup\r\n        // means we need to remove that user ID from that array rather than nuking\r\n        // the lot.\r\n        const existingUserIds = roomState._displayNameToUserIds[oldName] || [];\r\n        for (let i = 0; i < existingUserIds.length; i++) {\r\n            if (existingUserIds[i] === userId) {\r\n                // remove this user ID from this array\r\n                existingUserIds.splice(i, 1);\r\n                i--;\r\n            }\r\n        }\r\n        roomState._displayNameToUserIds[oldName] = existingUserIds;\r\n    }\r\n\r\n    roomState._userIdsToDisplayNames[userId] = displayName;\r\n    if (!roomState._displayNameToUserIds[displayName]) {\r\n        roomState._displayNameToUserIds[displayName] = [];\r\n    }\r\n    roomState._displayNameToUserIds[displayName].push(userId);\r\n}\r\n\r\n/**\r\n * Fires whenever the event dictionary in room state is updated.\r\n * @event module:client~MatrixClient#\"RoomState.events\"\r\n * @param {MatrixEvent} event The matrix event which caused this event to fire.\r\n * @param {RoomState} state The room state whose RoomState.events dictionary\r\n * was updated.\r\n * @example\r\n * matrixClient.on(\"RoomState.events\", function(event, state){\r\n *   var newStateEvent = event;\r\n * });\r\n */\r\n\r\n/**\r\n * Fires whenever a member in the members dictionary is updated in any way.\r\n * @event module:client~MatrixClient#\"RoomState.members\"\r\n * @param {MatrixEvent} event The matrix event which caused this event to fire.\r\n * @param {RoomState} state The room state whose RoomState.members dictionary\r\n * was updated.\r\n * @param {RoomMember} member The room member that was updated.\r\n * @example\r\n * matrixClient.on(\"RoomState.members\", function(event, state, member){\r\n *   var newMembershipState = member.membership;\r\n * });\r\n */\r\n\r\n /**\r\n * Fires whenever a member is added to the members dictionary. The RoomMember\r\n * will not be fully populated yet (e.g. no membership state).\r\n * @event module:client~MatrixClient#\"RoomState.newMember\"\r\n * @param {MatrixEvent} event The matrix event which caused this event to fire.\r\n * @param {RoomState} state The room state whose RoomState.members dictionary\r\n * was updated with a new entry.\r\n * @param {RoomMember} member The room member that was added.\r\n * @example\r\n * matrixClient.on(\"RoomState.newMember\", function(event, state, member){\r\n *   // add event listeners on 'member'\r\n * });\r\n */\r\n"]}